
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> library("tram")
Loading required package: mlt
Loading required package: basefun
Loading required package: variables
Loading required package: mvtnorm
> library("mvtnorm")
> library("multcomp")
Loading required package: survival
Loading required package: TH.data
Loading required package: MASS

Attaching package: 'TH.data'

The following object is masked from 'package:MASS':

    geyser

> library("sandwich")
> 
> options(digits = 2)
> 
> set.seed(25)
> chk <- function(...) all.equal(..., tol = 1e-3, check.attributes = FALSE)
> 
> J <- 4
> N <- 100
> S <- cov2cor(tcrossprod(matrix(runif(J * J), ncol = J)))
> y <- rmvnorm(N, sigma = S)
> u <- as.data.frame(plogis(y))
> x <- runif(N)
> d <- cbind(u, x)
> un <- colnames(d)[1:J]
> 
> m <- lapply(un, function(i)
+     BoxCox(as.formula(paste(i, "~ x")), data = d, bounds = c(0, 1), support = c(0, 1)))
> m$data <- d
> m$formula <- ~ 1
> mm <- do.call("mmlt", m)
> 
> chk(c(logLik(mm)), sum(predict(mm, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> L <- as.array(coef(mm, type = "Lambda"))[,,1]
> chk(as.array(coef(mm, type = "Lambdainv"))[,,1], solve(L))
[1] TRUE
> chk(as.array(coef(mm, type = "Sigma"))[,,1], tcrossprod(solve(L)))
[1] TRUE
> chk(as.array(coef(mm, type = "Cor"))[,,1], cov2cor(tcrossprod(solve(L))))
[1] TRUE
> 
> chk(colSums(estfun(mm)), mm$score(coef(mm, type = "all")))
[1] TRUE
> 
> ### marginal normal
> m$conditional <- FALSE
> mmN <- do.call("mmlt", m)
> 
> chk(logLik(mm), logLik(mmN))
[1] TRUE
> chk(c(logLik(mmN)), sum(predict(mmN, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> 
> cf1 <- do.call("c", lapply(m[1:J], function(x) coef(as.mlt(x))))
> cf2 <- coef(mmN)[1:length(cf1)]
> cbind(cf1, cf2)
           cf1    cf2
Bs1(V1) -3.893 -4.583
Bs2(V1) -0.905 -0.649
Bs3(V1) -0.905 -0.649
Bs4(V1) -0.078 -0.071
Bs5(V1)  0.935  0.750
Bs6(V1)  0.935  0.750
Bs7(V1)  3.951  4.365
x        0.013  0.028
Bs1(V2) -3.536 -3.254
Bs2(V2) -0.465 -1.312
Bs3(V2) -0.250  0.358
Bs4(V2)  0.159  0.358
Bs5(V2)  0.373  0.358
Bs6(V2)  1.912  1.615
Bs7(V2)  3.608  3.587
x        0.363  0.376
Bs1(V3) -3.179 -3.624
Bs2(V3) -0.690 -0.662
Bs3(V3) -0.690 -0.662
Bs4(V3) -0.114  0.215
Bs5(V3)  1.193  1.210
Bs6(V3)  1.193  1.210
Bs7(V3)  3.948  3.408
x        0.395  0.437
Bs1(V4) -3.748 -3.790
Bs2(V4) -0.297 -0.322
Bs3(V4) -0.297 -0.322
Bs4(V4) -0.297  0.015
Bs5(V4)  1.221  1.029
Bs6(V4)  1.221  1.029
Bs7(V4)  3.180  3.436
x        0.148  0.165
> 
> sd1 <- sqrt(do.call("c", lapply(m[1:J], function(x) diag(vcov(as.mlt(x))))))
> sd2 <- sqrt(diag(vcov(mmN)))[1:length(sd1)]
> 
> cbind(sd1, sd2)
         sd1  sd2
Bs1(V1) 2.32 0.87
Bs2(V1) 4.40 0.46
Bs3(V1) 6.42 0.46
Bs4(V1) 7.13 0.82
Bs5(V1) 6.24 0.45
Bs6(V1) 4.29 0.45
Bs7(V1) 2.36 0.86
x       0.34 0.34
Bs1(V2) 1.24 0.48
Bs2(V2) 2.39 0.41
Bs3(V2) 3.72 0.22
Bs4(V2) 4.35 0.22
Bs5(V2) 3.74 0.22
Bs6(V2) 2.36 0.43
Bs7(V2) 1.24 0.55
x       0.34 0.34
Bs1(V3) 1.13 0.51
Bs2(V3) 2.39 0.32
Bs3(V3) 3.87 0.32
Bs4(V3) 4.67 0.54
Bs5(V3) 4.34 0.31
Bs6(V3) 3.05 0.31
Bs7(V3) 1.68 0.54
x       0.34 0.34
Bs1(V4) 1.72 0.58
Bs2(V4) 3.06 0.34
Bs3(V4) 4.15 0.34
Bs4(V4) 4.21 0.61
Bs5(V4) 3.22 0.34
Bs6(V4) 1.81 0.34
Bs7(V4) 0.87 0.55
x       0.34 0.34
> vcov(mmN)["V1.x", "V4.x"]
[1] 0.059
> 
> 
> chk(as.array(coef(mm, type = "Lambda"))[,,1], 
+     as.array(coef(mmN, type = "Lambda"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, type = "Lambdainv"))[,,1], 
+     as.array(coef(mmN, type = "Lambdainv"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, type = "Sigma"))[,,1], 
+     as.array(coef(mmN, type = "Sigma"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, type = "Spearman"))[,,1], 
+     as.array(coef(mmN, type = "Spearman"))[,,1])
[1] TRUE
> 
> chk(predict(mm, newdata = d, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, type = "distribution", log = TRUE))
[1] TRUE
> 
> chk(predict(mm, newdata = d, margins = 1:2, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:2, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "distribution", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:3, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:3, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "distribution", log = TRUE))
[1] TRUE
> 
> chk(sapply(1:J, function(i) predict(mm, margins = i, newdata = d, type = "density", log = TRUE)),
+     sapply(1:J, function(i) predict(mmN, margins = i, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> 
> ### check marginal predictions
> m1 <- m[[1]]
> m2 <- do.call("mmlt", m[-(3:4)])
> m3 <- do.call("mmlt", m[-4])
> 
> chk(c(predict(m1, newdata = d, type = "density", log = TRUE)), 
+     c(predict(mmN, newdata = d, margins = 1, type = "density", log = TRUE)))
[1] "Mean relative difference: 0.17"
> chk(predict(m2, newdata = d, margins = 1:2, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "density", log = TRUE))
[1] "Mean relative difference: 0.14"
> chk(predict(m2, newdata = d, margins = 1:2, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "distribution", log = TRUE))
[1] "Mean relative difference: 0.037"
> chk(predict(m3, newdata = d, margins = 1:3, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "density", log = TRUE))
[1] "Mean relative difference: 0.082"
> chk(predict(m3, newdata = d, margins = 1:3, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "distribution", log = TRUE))
[1] "Mean relative difference: 0.026"
> 
> ### marginal normal, implemented differently
> for (j in 1:J) m[[j]]$todistr$name <- "CarlFriedrich"
> mmN <- do.call("mmlt", m)
> 
> chk(logLik(mm), logLik(mmN))
[1] TRUE
> chk(c(logLik(mmN)), sum(predict(mmN, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> 
> cf1 <- do.call("c", lapply(m[1:J], function(x) coef(as.mlt(x))))
> cf2 <- coef(mmN)[1:length(cf1)]
> cbind(cf1, cf2)
           cf1    cf2
Bs1(V1) -3.893 -4.583
Bs2(V1) -0.905 -0.649
Bs3(V1) -0.905 -0.649
Bs4(V1) -0.078 -0.071
Bs5(V1)  0.935  0.750
Bs6(V1)  0.935  0.750
Bs7(V1)  3.951  4.365
x        0.013  0.028
Bs1(V2) -3.536 -3.254
Bs2(V2) -0.465 -1.311
Bs3(V2) -0.250  0.358
Bs4(V2)  0.159  0.358
Bs5(V2)  0.373  0.358
Bs6(V2)  1.912  1.615
Bs7(V2)  3.608  3.587
x        0.363  0.376
Bs1(V3) -3.179 -3.624
Bs2(V3) -0.690 -0.662
Bs3(V3) -0.690 -0.662
Bs4(V3) -0.114  0.214
Bs5(V3)  1.193  1.210
Bs6(V3)  1.193  1.210
Bs7(V3)  3.948  3.408
x        0.395  0.437
Bs1(V4) -3.748 -3.790
Bs2(V4) -0.297 -0.322
Bs3(V4) -0.297 -0.322
Bs4(V4) -0.297  0.015
Bs5(V4)  1.221  1.029
Bs6(V4)  1.221  1.029
Bs7(V4)  3.180  3.436
x        0.148  0.165
> 
> sd1 <- sqrt(do.call("c", lapply(m[1:J], function(x) diag(vcov(as.mlt(x))))))
> sd2 <- sqrt(diag(vcov(mmN)))[1:length(sd1)]
> 
> cbind(sd1, sd2)
         sd1  sd2
Bs1(V1) 2.32 0.87
Bs2(V1) 4.40 0.46
Bs3(V1) 6.42 0.46
Bs4(V1) 7.13 0.82
Bs5(V1) 6.24 0.45
Bs6(V1) 4.29 0.45
Bs7(V1) 2.36 0.86
x       0.34 0.34
Bs1(V2) 1.24 0.48
Bs2(V2) 2.39 0.41
Bs3(V2) 3.72 0.22
Bs4(V2) 4.35 0.22
Bs5(V2) 3.74 0.22
Bs6(V2) 2.36 0.43
Bs7(V2) 1.24 0.55
x       0.34 0.34
Bs1(V3) 1.13 0.51
Bs2(V3) 2.39 0.32
Bs3(V3) 3.87 0.32
Bs4(V3) 4.67 0.54
Bs5(V3) 4.34 0.31
Bs6(V3) 3.05 0.31
Bs7(V3) 1.68 0.54
x       0.34 0.34
Bs1(V4) 1.72 0.58
Bs2(V4) 3.06 0.34
Bs3(V4) 4.15 0.34
Bs4(V4) 4.21 0.61
Bs5(V4) 3.22 0.34
Bs6(V4) 1.81 0.34
Bs7(V4) 0.87 0.55
x       0.34 0.34
> vcov(mmN)["V1.x", "V4.x"]
[1] 0.059
> 
> chk(as.array(coef(mm, type = "Lambda"))[,,1], 
+     as.array(coef(mmN, type = "Lambda"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, type = "Lambdainv"))[,,1], 
+     as.array(coef(mmN, type = "Lambdainv"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, type = "Sigma"))[,,1], 
+     as.array(coef(mmN, type = "Sigma"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, type = "Spearman"))[,,1], 
+     as.array(coef(mmN, type = "Spearman"))[,,1])
[1] TRUE
> 
> chk(predict(mm, newdata = d, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, type = "distribution", log = TRUE))
[1] TRUE
> 
> chk(predict(mm, newdata = d, margins = 1:2, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:2, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "distribution", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:3, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:3, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "distribution", log = TRUE))
[1] TRUE
> 
> chk(sapply(1:J, function(i) predict(mm, margins = i, newdata = d, type = "density", log = TRUE)),
+     sapply(1:J, function(i) predict(mmN, margins = i, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> 
> ### marginal Colr models
> m <- lapply(un, function(i)
+     Colr(as.formula(paste(i, "~ x")), data = d, bounds = c(0, 1), support = c(0, 1)))
> m$data <- d
> m$formula <- ~ 1
> mmC <- do.call("mmlt", m)
> 
> chk(c(logLik(mmC)), sum(predict(mmC, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> logLik(mmC)
'log Lik.' 310 (df=38)
> 
> ### conditional models
> m <- lapply(un, function(i)
+     BoxCox(as.formula(paste(i, "~ x")), data = d, bounds = c(0, 1), support = c(0, 1)))
> m$data <- d
> m$formula <- ~ x
> mm <- do.call("mmlt", m)
> 
> chk(c(logLik(mm)), sum(predict(mm, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> L <- as.array(coef(mm, newdata = d, type = "Lambda"))[,,1]
> chk(as.array(coef(mm, newdata = d, type = "Lambdainv"))[,,1], solve(L))
[1] TRUE
> chk(as.array(coef(mm, newdata = d, type = "Sigma"))[,,1], tcrossprod(solve(L)))
[1] TRUE
> chk(as.array(coef(mm, newdata = d, type = "Cor"))[,,1], cov2cor(tcrossprod(solve(L))))
[1] TRUE
> 
> ### with marginal parameterisation
> m$conditional <- FALSE
> mmN <- do.call("mmlt", m)
> 
> chk(logLik(mm), logLik(mmN))
[1] TRUE
> chk(c(logLik(mmN)), sum(predict(mmN, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> 
> chk(as.array(coef(mm, newdata = d, type = "Lambda"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Lambda"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, newdata = d, type = "Lambdainv"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Lambdainv"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, newdata = d, type = "Sigma"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Sigma"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, newdata = d, type = "Spearman"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Spearman"))[,,1])
[1] TRUE
> 
> chk(predict(mm, newdata = d, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, type = "distribution", log = TRUE))
[1] TRUE
> 
> chk(predict(mm, newdata = d, margins = 1:2, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:2, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "distribution", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:3, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:3, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "distribution", log = TRUE))
[1] TRUE
> 
> chk(sapply(1:J, function(i) predict(mm, margins = i, newdata = d, type = "density", log = TRUE)),
+     sapply(1:J, function(i) predict(mmN, margins = i, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> 
> ### implemented differently
> for (j in 1:J) m[[j]]$todistr$name <- "CarlFriedrich"
> mmN <- do.call("mmlt", m)
> 
> chk(logLik(mm), logLik(mmN))
[1] TRUE
> chk(c(logLik(mmN)), sum(predict(mmN, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> 
> chk(as.array(coef(mm, newdata = d, type = "Lambda"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Lambda"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, newdata = d, type = "Lambdainv"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Lambdainv"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, newdata = d, type = "Sigma"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Sigma"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, newdata = d, type = "Spearman"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Spearman"))[,,1])
[1] TRUE
> 
> chk(predict(mm, newdata = d, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, type = "distribution", log = TRUE))
[1] TRUE
> 
> chk(predict(mm, newdata = d, margins = 1:2, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:2, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "distribution", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:3, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:3, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "distribution", log = TRUE))
[1] TRUE
> 
> chk(sapply(1:J, function(i) predict(mm, margins = i, newdata = d, type = "density", log = TRUE)),
+     sapply(1:J, function(i) predict(mmN, margins = i, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> 
> ### conditional Colr
> m <- lapply(un, function(i)
+     Colr(as.formula(paste(i, "~ x")), data = d, bounds = c(0, 1), support = c(0, 1)))
> m$data <- d
> m$formula <- ~ x
> mmC <- do.call("mmlt", m)
> 
> chk(c(logLik(mmC)), sum(predict(mmC, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> logLik(mmC)
'log Lik.' 313 (df=44)
> 
> ##### FIRST SCENARIO: CONSTANT LAMBDA #####
> set.seed(290875)
> ll <- numeric(50)
> p <- 3
> X <- matrix(runif(N * p), ncol = p)
> m1 <- 1 + X %*% c(2, 1, 1)
> m2 <- 1 + X %*% c(1, 2, 1)
> lb <- (off <- 0.5) + X %*% (cf <- c(0, 2, 0))
> d <- data.frame(X)
> Y <- matrix(NA, nrow = N, ncol = 2)
> colnames(Y) <- c("Y1", "Y2")
> 
> cr <- numeric(N)
> for (i in 1:N) {
+   Si <- diag(2)
+   Si[1,2] <- Si[2,1] <- .5
+   cr[i] <- cov2cor(Si)[2,1]
+   
+   Y[i,] <- rmvnorm(1, mean = c(m1[i], m2[i]), sigma = Si)
+ }
> 
> 
> ##### only BoxCox margins: ##### 
> d <- cbind(d, Y)
> b1 <- as.mlt(Lm(Y1 ~ X1 + X2 + X3, data = d))
> b2 <- as.mlt(Lm(Y2 ~ X1 + X2 + X3, data = d))
> 
> ## constant correlations. expect identical logliks and lambda parameters
> mm01 <- mmlt(b1, b2, formula = ~ 1, data = d)
> mm02 <- mmlt(b2, b1, formula = ~ 1, data = d)
> 
> chk(logLik(mm01), logLik(mm02))
[1] TRUE
> 
> chk(c(coef(mm01)["Y2.Y1.(Intercept)"]), 
+     c(coef(mm02)["Y1.Y2.(Intercept)"]))
[1] TRUE
> 
> ## checking gradients
> chk(c(numDeriv::grad(mm01$ll, mm02$par)),
+     c(mm01$sc(mm02$par)))
[1] TRUE
> 
> ## predicting marginal distributions and comparing across models with constant lambda
> predict(mm01, newdata = d[1:5,], q = -2:2, 
+         margins = 1, type = "distribution")
       
Y1         [,1]    [,2]    [,3]    [,4]    [,5]
     -2 4.9e-09 1.8e-05 5.6e-14 4.3e-08 1.1e-09
     -1 2.0e-06 1.3e-03 1.4e-10 1.1e-05 5.7e-07
      0 2.3e-04 2.8e-02 1.0e-07 9.1e-04 8.9e-05
      1 8.6e-03 2.2e-01 2.3e-05 2.3e-02 4.3e-03
      2 1.0e-01 6.3e-01 1.5e-03 1.9e-01 6.5e-02
> predict(mm02, newdata = d[1:5,], q = -2:2, 
+         margins = 2, type = "distribution")
       
Y1         [,1]    [,2]    [,3]    [,4]    [,5]
     -2 4.9e-09 1.8e-05 5.6e-14 4.3e-08 1.1e-09
     -1 2.0e-06 1.3e-03 1.4e-10 1.1e-05 5.7e-07
      0 2.3e-04 2.8e-02 1.0e-07 9.1e-04 8.9e-05
      1 8.6e-03 2.2e-01 2.3e-05 2.3e-02 4.3e-03
      2 1.0e-01 6.3e-01 1.5e-03 1.9e-01 6.5e-02
> 
> ## expect correlations to be the same for the model with constant lambdas
> chk(c(coef(mm01, newdata = d[1:5,], type = "Cor")), 
+     c(coef(mm02, newdata = d[1:5,], type = "Cor")))
[1] TRUE
> 
> 
> ##### mix of BoxCox and Colr margins: ##### 
> d$Y1 <- (d$Y1 - min(d$Y1))/(max(d$Y1) - min(d$Y1))
> 
> b1 <- as.mlt(Colr(Y1 ~ X1 + X2 + X3, data = d, order = 1))
> b2 <- as.mlt(Lm(Y2 ~ X1 + X2 + X3, data = d))
> 
> mm01 <- mmlt(b1, b2, formula = ~ 1, data = d)
> mm02 <- mmlt(b2, b1, formula = ~ 1, data = d)
> 
> chk(logLik(mm01), logLik(mm02))
[1] TRUE
> 
> ### model is marginal, so expect same marginal coeff
> cf1 <- coef(mm01)
> cf1 <- cf1[-length(cf1)]
> cf2 <- coef(mm02)
> cf2 <- cf2[names(cf1)]
> chk(cf1, cf2)
[1] TRUE
> 
> ## checking gradient
> chk(c(numDeriv::grad(mm01$ll, coef(mm01))), c(mm01$sc(coef(mm01))))
[1] TRUE
> chk(c(numDeriv::grad(mm02$ll, coef(mm02))), c(mm02$sc(coef(mm02)))) 
[1] TRUE
> 
> ##### SECOND SCENARIO: COVARIATE DEPENDENT LAMBDA #####
> set.seed(290875)
> ll <- numeric(50)
> X <- matrix(runif(N * p), ncol = p)
> m1 <- 1 + X %*% c(2, 1, 1)
> m2 <- 1 + X %*% c(1, 2, 1)
> lb <- (off <- 0.5) + X %*% (cf <- c(0, 2, 0))
> d <- data.frame(X)
> Y <- matrix(NA, nrow = N, ncol = 2)
> colnames(Y) <- c("Y1", "Y2")
> 
> cr <- numeric(N)
> for (i in 1:N) {
+   L <- diag(2)
+   L[2,1] <- lb[i]
+   Si <- solve(L) %*% t(solve(L))
+   cr[i] <- cov2cor(Si)[2,1]
+   
+   Y[i,] <- rmvnorm(1, mean = c(m1[i], m2[i]), sigma = Si)
+ }
> 
> 
> ##### only BoxCox margins: ##### 
> d <- cbind(d, Y)
> b1 <- as.mlt(Lm(Y1 ~ X1 + X2 + X3, data = d))
> b2 <- as.mlt(Lm(Y2 ~ X1 + X2 + X3, data = d))
> 
> ## constant correlations. expect identical logliks and lambda parameters
> mm01 <- mmlt(b1, b2, formula = ~ 1, data = d)
> mm02 <- mmlt(b2, b1, formula = ~ 1, data = d)
> 
> chk(logLik(mm01), logLik(mm02))
[1] TRUE
> 
> ## x-dependent correlations. expect slightly different logliks
> mm1 <- mmlt(b1, b2, formula = ~ X1 + X2 + X3, data = d)
> mm2 <- mmlt(b2, b1, formula = ~ X1 + X2 + X3, data = d)
> 
> logLik(mm1)
'log Lik.' -277 (df=14)
> logLik(mm2)
'log Lik.' -277 (df=14)
> 
> ## checking gradients
> chk(c(numDeriv::grad(mm01$ll, mm02$par)),c(mm01$sc(mm02$par)))
[1] TRUE
> chk(c(numDeriv::grad(mm1$ll, mm2$par)),c(mm1$sc(mm2$par)))
[1] TRUE
> 
> ### BUT
> mm1 <- mmlt(b1, b2, formula = ~ X1 + X2 + X3, data = d, conditional = FALSE)
> mm2 <- mmlt(b2, b1, formula = ~ X1 + X2 + X3, data = d, conditional = FALSE)
> 
> logLik(mm1)
'log Lik.' -277 (df=14)
> logLik(mm2)
'log Lik.' -277 (df=14)
> 
> ## predicting marginal distributions and comparing across models with constant lambda
> x <- 0:4 / 4
> nd <- expand.grid(X1 = x, X2 = x, X3 = x)
> predict(mm01, newdata = nd[1:5,], q = -2:2, 
+         margins = 1, type = "distribution")
       
Y1         [,1]    [,2]    [,3]    [,4]    [,5]
     -2 0.00045 3.8e-05 2.1e-06 8.2e-08 2.1e-09
     -1 0.01047 1.6e-03 1.7e-04 1.2e-05 5.8e-07
      0 0.09727 2.6e-02 5.0e-03 6.6e-04 5.9e-05
      1 0.38758 1.8e-01 5.9e-02 1.4e-02 2.3e-03
      2 0.76608 5.3e-01 2.9e-01 1.2e-01 3.4e-02
> predict(mm02, newdata = nd[1:5,], q = -2:2, 
+         margins = 2, type = "distribution")
       
Y1         [,1]    [,2]    [,3]    [,4]    [,5]
     -2 0.00045 3.8e-05 2.1e-06 8.2e-08 2.1e-09
     -1 0.01047 1.6e-03 1.7e-04 1.2e-05 5.8e-07
      0 0.09727 2.6e-02 5.0e-03 6.6e-04 5.9e-05
      1 0.38758 1.8e-01 5.9e-02 1.4e-02 2.3e-03
      2 0.76608 5.3e-01 2.9e-01 1.2e-01 3.4e-02
> 
> predict(mm1, newdata = nd[1:5,], q = -2:2, 
+         margins = 1, type = "distribution")
       
Y1         [,1]    [,2]    [,3]    [,4]    [,5]
     -2 0.00025 1.8e-05 8.3e-07 2.6e-08 5.3e-10
     -1 0.00769 1.0e-03 9.5e-05 5.7e-06 2.3e-07
      0 0.08624 2.2e-02 3.8e-03 4.4e-04 3.4e-05
      1 0.38017 1.7e-01 5.3e-02 1.2e-02 1.7e-03
      2 0.77463 5.4e-01 2.9e-01 1.1e-01 3.1e-02
> predict(mm2, newdata = nd[1:5,], q = -2:2, 
+         margins = 2, type = "distribution")
       
Y1         [,1]    [,2]    [,3]    [,4]    [,5]
     -2 0.00025 1.8e-05 8.3e-07 2.6e-08 5.3e-10
     -1 0.00769 1.0e-03 9.5e-05 5.7e-06 2.3e-07
      0 0.08624 2.2e-02 3.8e-03 4.4e-04 3.4e-05
      1 0.38017 1.7e-01 5.3e-02 1.2e-02 1.7e-03
      2 0.77463 5.4e-01 2.9e-01 1.1e-01 3.1e-02
> 
> ## expect correlations to be the same for the model with constant lambdas
> chk(c(coef(mm01, newdata = nd[1:5,], type = "Cor")), 
+     c(coef(mm02, newdata = nd[1:5,], type = "Cor")))
[1] TRUE
> 
> ## correlations for models with x-dependent lambda
> c(coef(mm1, newdata = nd[1:5,], type = "Cor"))
[1] -0.88 -0.85 -0.80 -0.73 -0.63
> c(coef(mm2, newdata = nd[1:5,], type = "Cor"))
[1] -0.88 -0.85 -0.80 -0.73 -0.63
> 
> 
> ##### mix of BoxCox and Colr margins: ##### 
> d$Y1 <- (d$Y1 - min(d$Y1))/(max(d$Y1) - min(d$Y1))
> 
> b1 <- as.mlt(Colr(Y1 ~ X1 + X2 + X3, data = d, order = 1))
> b2 <- as.mlt(Lm(Y2 ~ X1 + X2 + X3, data = d))
> 
> mm01 <- mmlt(b1, b2, formula = ~ 1, data = d)
> mm02 <- mmlt(b2, b1, formula = ~ 1, data = d)
> 
> chk(logLik(mm01), logLik(mm02))
[1] TRUE
> 
> coef(b1)
Bs1(Y1) Bs2(Y1)      X1      X2      X3 
   0.52    6.09   -4.35   -1.43   -0.66 
> coef(b2)
(Intercept)          Y2          X1          X2          X3 
      -0.18        0.53        0.34        1.06        1.20 
> coef(mm01)
       Y1.Bs1(Y1)        Y1.Bs2(Y1)             Y1.X1             Y1.X2 
             0.50              6.08             -4.25             -1.44 
            Y1.X3    Y2.(Intercept)             Y2.Y2             Y2.X1 
            -0.66             -0.17              0.52              0.41 
            Y2.X2             Y2.X3 Y2.Y1.(Intercept) 
             1.01              1.17              1.51 
> coef(mm02)
   Y2.(Intercept)             Y2.Y2             Y2.X1             Y2.X2 
            -0.17              0.52              0.41              1.01 
            Y2.X3        Y1.Bs1(Y1)        Y1.Bs2(Y1)             Y1.X1 
             1.17              0.50              6.08             -4.25 
            Y1.X2             Y1.X3 Y1.Y2.(Intercept) 
            -1.44             -0.66              1.51 
> # remember that: lb <- (off <- 0.5) + X %*% (cf <- c(0, 2, 0))
> 
> 
> ## checking gradient
> chk(c(numDeriv::grad(mm01$ll, coef(mm01))),c(mm01$sc(coef(mm01))))
[1] TRUE
> chk(c(numDeriv::grad(mm02$ll, coef(mm02))),c(mm02$sc(coef(mm02))))
[1] TRUE
> 
> ## covariate-dependent Lambda
> mm1 <- mmlt(b1, b2, formula = ~ X1 + X2 + X3, data = d)
> mm2 <- mmlt(b2, b1, formula = ~ X1 + X2 + X3, data = d)
> logLik(mm1)
'log Lik.' -88 (df=14)
> logLik(mm2)
'log Lik.' -88 (df=14)
> 
> coef(b1)
Bs1(Y1) Bs2(Y1)      X1      X2      X3 
   0.52    6.09   -4.35   -1.43   -0.66 
> coef(b2)
(Intercept)          Y2          X1          X2          X3 
      -0.18        0.53        0.34        1.06        1.20 
> coef(mm1)
       Y1.Bs1(Y1)        Y1.Bs2(Y1)             Y1.X1             Y1.X2 
             0.43              6.29             -4.43             -1.28 
            Y1.X3    Y2.(Intercept)             Y2.Y2             Y2.X1 
            -0.81             -0.10              0.50              0.32 
            Y2.X2             Y2.X3 Y2.Y1.(Intercept)          Y2.Y1.X1 
             1.13              1.11              1.92             -1.13 
         Y2.Y1.X2          Y2.Y1.X3 
             1.76             -1.09 
> coef(mm2)
   Y2.(Intercept)             Y2.Y2             Y2.X1             Y2.X2 
            -0.10              0.50              0.32              1.13 
            Y2.X3        Y1.Bs1(Y1)        Y1.Bs2(Y1)             Y1.X1 
             1.11              0.43              6.29             -4.43 
            Y1.X2             Y1.X3 Y1.Y2.(Intercept)          Y1.Y2.X1 
            -1.28             -0.81              1.92             -1.13 
         Y1.Y2.X2          Y1.Y2.X3 
             1.76             -1.09 
> # remember that: lb <- (off <- 0.5) + X %*% (cf <- c(0, 2, 0))
> 
> ## checking gradient for diag = TRUE
> chk(c(numDeriv::grad(mm1$ll, coef(mm1))),c(mm1$sc(coef(mm1))))
[1] TRUE
> chk(c(numDeriv::grad(mm2$ll, coef(mm2))),c(mm2$sc(coef(mm2))))
[1] TRUE
> 
> ### very simple checks with marginal Lm models
> set.seed(290875)
> J <- 4
> S <- cov2cor(tcrossprod(matrix(runif(J * J), ncol = J)))
> x <- matrix(runif(N*2), ncol = 2)
> 
> y <- x %*% matrix(c(1, -1, -.5, .5, -.2, .2, .3, -.3), nrow = 2) + rmvnorm(N, sigma = S)
> d <- data.frame(y = y, x = x)
> 
> m1 <- Lm(y.1 ~ x.1 + x.2, data = d)
> m2 <- Lm(y.2 ~ x.1 + x.2, data = d)
> m3 <- Lm(y.3 ~ x.1 + x.2, data = d)
> m4 <- Lm(y.4 ~ x.1 + x.2, data = d)
> 
> ## simple formula
> mc01 <- mmlt(m1, m2, m3, m4, formula = ~ 1, data = d, conditional = FALSE)
> 
> cf <- coef(mc01)
> vr <- diag(vcov(mc01))
> i <- grep("x", names(cf))
> 
> ### same results
> ret <- cbind(c(coef(m1), coef(m2), coef(m3), coef(m4)),
+              cf[i],
+              c(diag(vcov(m1)), diag(vcov(m2)), diag(vcov(m3)), diag(vcov(m4))),
+              vr[i])
> ret
      [,1]   [,2] [,3] [,4]
x.1  1.036  1.036 0.13 0.13
x.2 -1.184 -1.184 0.14 0.14
x.1 -0.702 -0.702 0.12 0.12
x.2  0.743  0.743 0.13 0.13
x.1 -0.585 -0.585 0.12 0.12
x.2  0.156  0.156 0.13 0.13
x.1  0.038  0.038 0.12 0.12
x.2 -0.420 -0.420 0.13 0.13
> 
> vc <- vcov(mc01)
> i <- grep("x.1", colnames(vc))
> vc[i,i]
        y.1.x.1 y.2.x.1 y.3.x.1 y.4.x.1
y.1.x.1   0.127   0.029   0.085   0.072
y.2.x.1   0.029   0.124   0.087   0.070
y.3.x.1   0.085   0.087   0.124   0.111
y.4.x.1   0.072   0.070   0.111   0.122
> 
> summary(g1 <- glht(mmm(m1 = as.mlt(m1), m2 = as.mlt(m2), m3 = as.mlt(m3), m4 = as.mlt(m4)), mlf("x.1 = 0")))

	 Simultaneous Tests for General Linear Hypotheses

Linear Hypotheses:
             Estimate Std. Error z value Pr(>|z|)  
m1: x.1 == 0   1.0365     0.3569    2.90    0.012 *
m2: x.1 == 0  -0.7019     0.3528   -1.99    0.126  
m3: x.1 == 0  -0.5846     0.3517   -1.66    0.241  
m4: x.1 == 0   0.0383     0.3493    0.11    1.000  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
(Adjusted p values reported -- single-step method)

> 
> summary(g2 <- glht(mc01, c("y.1.x.1 = 0", "y.2.x.1 = 0", "y.3.x.1 = 0", "y.4.x.1 = 0")))

	 Simultaneous Tests for General Linear Hypotheses

Fit: mmlt(m1, m2, m3, m4, formula = ~1, data = d, conditional = FALSE)

Linear Hypotheses:
             Estimate Std. Error z value Pr(>|z|)  
y.1.x.1 == 0   1.0365     0.3569    2.90    0.011 *
y.2.x.1 == 0  -0.7019     0.3528   -1.99    0.126  
y.3.x.1 == 0  -0.5846     0.3517   -1.66    0.241  
y.4.x.1 == 0   0.0383     0.3493    0.11    1.000  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
(Adjusted p values reported -- single-step method)

> 
> vcov(g1)
        m1: x.1 m2: x.1 m3: x.1 m4: x.1
m1: x.1   0.127   0.029   0.086   0.078
m2: x.1   0.029   0.124   0.086   0.065
m3: x.1   0.086   0.086   0.124   0.111
m4: x.1   0.078   0.065   0.111   0.122
> vcov(g2)
        y.1.x.1 y.2.x.1 y.3.x.1 y.4.x.1
y.1.x.1   0.127   0.029   0.085   0.072
y.2.x.1   0.029   0.124   0.087   0.070
y.3.x.1   0.085   0.087   0.124   0.111
y.4.x.1   0.072   0.070   0.111   0.122
> 
> 
> #### check density
> Shat <- as.array(coef(mc01, type = "Cor"))[,,1]
> 
> int <- cf[paste("y", 1:J, "(Intercept)", sep = ".")]
> fct <- cf[paste("y", 1:J, "y", 1:J, sep = ".")]
> 
> d1 <- sapply(1:N, function(i) dmvnorm(int + fct * y[i,], mean = x[i,,drop = FALSE] %*% matrix(ret[,1], nrow = 2), sigma = Shat, log = TRUE))
> d2 <- predict(mc01, newdata = d, type = "density", log = TRUE)
> 
> chk(c(d1), c(d2))
[1] "Mean relative difference: 0.076"
> 
> chk(c(logLik(mmlt(m1, m2, m3, m4, formula = ~ 1, data = d))),
+     c(logLik(mc01)))
[1] TRUE
> chk(c(logLik(mc01)),
+     sum(d2))
[1] TRUE
> 
> ### check if newdata works in logLik
> chk(logLik(mc01), logLik(mc01, newdata = d))
[1] TRUE
> 
> proc.time()
   user  system elapsed 
  42.59    0.11   42.70 
