
R version 3.1.2 (2014-10-31) -- "Pumpkin Helmet"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> library("mlt")
Loading required package: basefun
Loading required package: Matrix
Loading required package: polynom
> set.seed(29)
> 
> n <- 100
> p <- 2
> x <- matrix(runif(n * p), nrow = n)
> beta <- c(1, -1)
> y <- factor(rbinom(n, size = 1, prob = plogis(x %*% beta)))
> df <- data.frame(y = y, x)
> 
> m1 <- glm(y ~ X1 + X2, data = df, family = binomial())
> coef(m1)
(Intercept)          X1          X2 
  0.7372381  -0.3848546  -0.8292045 
> 
> m <- model(~ y, shift = ~ X1 + X2, todist = "Logis")
> m2 <- mlt(m, data = df, fixed = c("y.L" = 0))
Warning message:
In mlt(m, data = df, fixed = c(y.L = 0)) :
  results may depend on ordering of levels
> coef(m2)
(Intercept)         y.L          X1          X2 
 -0.7367964   0.0000000   0.3847043   0.8285499 
> 
> max(abs(coef(m1) + coef(m2)[-2]))
[1] 0.0006546535
> 
> logLik(m1)
'log Lik.' -68.12815 (df=3)
> logLik(m2)
'log Lik.' -68.12815 (df=3)
> 
> library("nnet")
> 
> m1 <- multinom(Species ~ ., data = iris)
# weights:  18 (10 variable)
initial  value 164.791843 
iter  10 value 16.177348
iter  20 value 7.111438
iter  30 value 6.182999
iter  40 value 5.984028
iter  50 value 5.961278
iter  60 value 5.954900
iter  70 value 5.951851
iter  80 value 5.950343
iter  90 value 5.949904
iter 100 value 5.949867
final  value 5.949867 
stopped after 100 iterations
> coef(m1)
           (Intercept) Sepal.Length Sepal.Width Petal.Length Petal.Width
versicolor    18.69037    -5.458424   -8.707401     14.24477   -3.097684
virginica    -23.83628    -7.923634  -15.370769     23.65978   15.135301
> 
> oiris <- iris
> oiris$Species <- ordered(oiris$Species)
> 
> r <- as.basis(~ Species, data = oiris, remove_intercept = TRUE,
+               contrasts.arg = list(Species = function(n)
+                   contr.treatment(n, base = 3)),
+               ui = diff(Diagonal(2)), ci = rep(0, 1))
> 
> m <- model(r, interacting = ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width,
+            todistr = "Logis")
> m2 <- mlt(m, data = oiris)
Note: method with signature 'diagonalMatrix#Matrix' chosen for function 'kronecker',
 target signature 'ddiMatrix#dgCMatrix'.
 "ANY#sparseMatrix" would also be valid
Note: method with signature 'dsparseMatrix#dsparseMatrix' chosen for function 'kronecker',
 target signature 'dtTMatrix#dgCMatrix'.
 "TsparseMatrix#sparseMatrix" would also be valid
Note: method with signature 'diagonalMatrix#Matrix' chosen for function 'kronecker',
 target signature 'ddiMatrix#ddiMatrix'.
 "Matrix#diagonalMatrix" would also be valid
Note: method with signature 'TsparseMatrix#sparseMatrix' chosen for function 'kronecker',
 target signature 'dtTMatrix#ddiMatrix'.
 "Matrix#diagonalMatrix" would also be valid
Note: method with signature 'Matrix#numLike' chosen for function '%*%',
 target signature 'dtTMatrix#numeric'.
 "TsparseMatrix#ANY" would also be valid
Note: method with signature 'Matrix#matrix' chosen for function '%*%',
 target signature 'dtTMatrix#matrix'.
 "TsparseMatrix#ANY" would also be valid
Note: method with signature 'Matrix#numLike' chosen for function '%*%',
 target signature 'dgTMatrix#numeric'.
 "TsparseMatrix#ANY" would also be valid
Note: method with signature 'Matrix#matrix' chosen for function '%*%',
 target signature 'dgTMatrix#matrix'.
 "TsparseMatrix#ANY" would also be valid
> coef(m2)
  Species1   Species2   Species1   Species2   Species1   Species2   Species1 
  2.923577  42.514888   2.395331   2.463351   6.340664   6.675611  -9.418430 
  Species2   Species1   Species2 
 -9.407884 -18.261442 -18.260244 
> 
> s <- sort(unique(oiris$Species))[1:2]
> p2 <- do.call("rbind", lapply(predict(m2, newdata = oiris), 
+                               function(f) f(s, type = "prob")))
> pp2 <- cbind(p2[,1], p2[,2] - p2[,1], 1 - p2[,2])
> 
> pp1 <- predict(m1, newdata = iris, type = "prob")
> 
> max(abs(pp1 - pp2))
[1] 0.001021454
> 
> 
> proc.time()
   user  system elapsed 
  5.089   0.032   5.115 
