
R version 3.2.1 (2015-06-18) -- "World-Famous Astronaut"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> library("mlt")
Loading required package: basefun
> library("lattice")
> 
> data("faithful")
> 
> aic <- numeric(20)
> 
> for (o in 2:(length(aic) + 1)) {
+ Bs <- Bernstein_basis(order = o, var = "waiting", ui = "incre", 
+                       support = range(faithful$waiting) + c(-5, 5))
+ m <- model(Bs)
+ mod <- mlt(m, data = faithful)
+ yp <- mkgrid(mod, 50)[["waiting"]]
+ 
+ aic[o - 1] <- AIC(mod)
+ 
+ pd <- data.frame(waiting = yp)
+ pd$p <- predict(mod, q = yp, type = "distribution")
+ 
+ plot(p ~ waiting, data = pd,
+      col = "red", pch = 21, main = paste("order", o, "aic", aic[o - 1]))
+ lines(ecdf(faithful$waiting))
+ 
+ }
Gradient[1] "Mean relative difference: 0.000698944"
Hessian:[1] TRUE
Gradient[1] TRUE
Hessian:[1] TRUE
Gradient[1] TRUE
Hessian:[1] TRUE
Gradient[1] TRUE
Hessian:[1] TRUE
Gradient[1] TRUE
Hessian:[1] TRUE
Gradient[1] TRUE
Hessian:[1] TRUE
Gradient[1] "Mean relative difference: 2.735775e-08"
Hessian:[1] TRUE
Gradient[1] TRUE
Hessian:[1] TRUE
Gradient[1] TRUE
Hessian:[1] TRUE
Gradient[1] "Mean relative difference: 1.526991e-08"
Hessian:[1] TRUE
Gradient[1] TRUE
Hessian:[1] TRUE
Gradient[1] TRUE
Hessian:[1] TRUE
Gradient[1] TRUE
Hessian:[1] TRUE
Gradient[1] TRUE
Hessian:[1] TRUE
Gradient[1] "Mean relative difference: 1.50821e-08"
Hessian:[1] TRUE
Gradient[1] "Mean relative difference: 1.562013e-08"
Hessian:[1] TRUE
Gradient[1] "Mean relative difference: 1.649378e-08"
Hessian:[1] TRUE
Gradient[1] "Mean relative difference: 3.764643e-08"
Hessian:[1] TRUE
Gradient[1] "Mean relative difference: 3.553898e-08"
Hessian:[1] TRUE
Gradient[1] "Mean relative difference: 3.361534e-08"
Hessian:[1] TRUE
Warning message:
In spg(par = theta, fn = loglikfct, gr = scorefct, project = "projectLinear",  :
  Unsuccessful convergence.
> 
> plot(aic)
> 
> o <- which.min(aic) + 1
> Bs <- Bernstein_basis(order = o, var = "waiting", ui = "incre",
+                       support = range(faithful$waiting) + c(-5, 5))
> m <- model(Bs)
> mod <- mlt(m, data = faithful)
Gradient[1] "Mean relative difference: 2.735775e-08"
Hessian:[1] TRUE
> 
> abline(h = AIC(mod))
> 
> pd$d <- predict(mod, q = yp, type = "density")
> 
> plot(d ~ waiting, data = pd, type = "l", col = "red", lwd = 3)
> lines(density(faithful$waiting))
> lines(rug(faithful$waiting))
> abline(h = 0)
> 
> p <- 1:99 / 100
> q <- predict(mod, p = p, n = 100, type = "quantile")
> 
> plot(p, q)
> lines(p, quantile(faithful$waiting, p))
> 
> Bs <- Bernstein_basis(order = o, var = "waiting", ui = "incre", # normal = TRUE,
+                       support = range(faithful$waiting) + c(-5, 5))
> m <- model(Bs)
> mod <- mlt(m, data = faithful)
Gradient[1] "Mean relative difference: 2.735775e-08"
Hessian:[1] TRUE
> 
> # H1 <- mod$optim(coef(mod), hessian = TRUE)$hessian
> H2 <- mod$hessian(coef(mod))
> 
> X <- model.matrix(m, faithful)
> Xprime <- model.matrix(m, faithful, deriv = c(waiting = 1))
> w <- drop((Xprime %*% coef(mod))^2)
> H3 <- crossprod(X) + crossprod(Xprime * w, Xprime)
> max(abs(H3 - H2))
[1] 9.885543
> 
> cov2cor(vcov(mod))
             Bs1(waiting) Bs2(waiting) Bs3(waiting) Bs4(waiting) Bs5(waiting)
Bs1(waiting)    1.0000000   -0.9652655    0.9032052   -0.8310316    0.7513994
Bs2(waiting)   -0.9652655    1.0000000   -0.9793104    0.9309905   -0.8628107
Bs3(waiting)    0.9032052   -0.9793104    1.0000000   -0.9835440    0.9383218
Bs4(waiting)   -0.8310316    0.9309905   -0.9835440    1.0000000   -0.9837277
Bs5(waiting)    0.7513994   -0.8628107    0.9383218   -0.9837277    1.0000000
Bs6(waiting)   -0.6649917    0.7788032   -0.8677579    0.9357828   -0.9824465
Bs7(waiting)    0.5741521   -0.6830276    0.7767006   -0.8583341    0.9286162
Bs8(waiting)   -0.4756209    0.5730194   -0.6625695    0.7479340   -0.8313482
Bs9(waiting)    0.3573293   -0.4341435    0.5079549   -0.5821465    0.6606654
             Bs6(waiting) Bs7(waiting) Bs8(waiting) Bs9(waiting)
Bs1(waiting)   -0.6649917    0.5741521   -0.4756209    0.3573293
Bs2(waiting)    0.7788032   -0.6830276    0.5730194   -0.4341435
Bs3(waiting)   -0.8677579    0.7767006   -0.6625695    0.5079549
Bs4(waiting)    0.9357828   -0.8583341    0.7479340   -0.5821465
Bs5(waiting)   -0.9824465    0.9286162   -0.8313482    0.6606654
Bs6(waiting)    1.0000000   -0.9794871    0.9079639   -0.7427119
Bs7(waiting)   -0.9794871    1.0000000   -0.9699965    0.8292216
Bs8(waiting)    0.9079639   -0.9699965    1.0000000   -0.9214161
Bs9(waiting)   -0.7427119    0.8292216   -0.9214161    1.0000000
> 
> if (TRUE) {
+ library("multcomp") ### since 1.0-3
+ 
+ mp <- parm(coef(mod), vcov(mod))
+ y <- mkgrid(mod, 30)$waiting
+ g <- glht(mp, linfct = model.matrix(mod$model,
+     data = data.frame(waiting = y)))
+ 
+ mc <- confint(g)
+ umc <- confint(g, calpha = qnorm(.975))
+ p <- mod$model$todistr$p
+ plot(y, p(mc$confint[, "Estimate"]), type = "l")
+ lines(y, p(mc$confint[, "lwr"]))
+ lines(y, p(mc$confint[, "upr"]))
+ lines(y, p(umc$confint[, "lwr"]))
+ lines(y, p(umc$confint[, "upr"]))
+ 
+ library("survival")
+ cm <- coxph(Surv(waiting, rep(TRUE, nrow(faithful))) ~ 1, data = faithful)
+ plot(survfit(cm))
+ lines(y, 1 - p(mc$confint[, "Estimate"]), col = "red")
+ lines(y, 1 - p(mc$confint[, "lwr"]), col = "red")
+ lines(y, 1 - p(mc$confint[, "upr"]), col = "red")
+ }
Loading required package: mvtnorm
Loading required package: survival
Loading required package: TH.data
> 
> proc.time()
   user  system elapsed 
 17.092   0.031  17.122 
