
R version 3.2.1 (2015-06-18) -- "World-Famous Astronaut"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> library("mlt")
Loading required package: basefun
> library("survival")
> set.seed(29)
> 
> ### true dgp
> rY <- function(n, ...) rexp(n, ...)
> pY <- function(x, ...) pexp(x, ...)
> dY <- function(x, ...) dexp(x, ...)
> 
> ### tree groups
> gf <- gl(3, 1)
> g <- rep(gf, 100)
> y <- rY(length(g), rate = (1:nlevels(g))[g])
> mydata <- data.frame(y = y, g = g)
> 
> boxplot(y ~ g, data = mydata)
> 
> ### uncensored, Cox model, h = bernstein
> Bb <- Bernstein_basis(order = 5, support = c(0, max(y) + .1),
+                       ui = "increasing", var = "y")
> s <- as.basis(~ g, data = data.frame(g = gf), remove_intercept = TRUE)
> m <- model(response = Bb, shifting = s, todist = "MinExtrVal")
> (cf1 <- coef(opt <- mlt(m, data = mydata)))
Gradient[1] TRUE
Hessian:[1] TRUE
    Bs1(y)     Bs2(y)     Bs3(y)     Bs4(y)     Bs5(y)     Bs6(y)         g2 
-2.5706843  1.1035974  1.1035974  1.1035974  1.1035974  1.8004139  0.9323842 
        g3 
 1.2627559 
> coef(cph <- coxph(Surv(y, rep(TRUE, nrow(mydata))) ~ g, data = mydata))
      g2       g3 
0.699808 1.022699 
> yn <- mkgrid(Bb, 50)$y
> yn <- yn[yn > 0]
> a <- predict(opt, newdata = data.frame(g = gf[1]), q = yn)
> layout(matrix(1:4, ncol = 2))
> plot(yn, a, type = "l", col = "red")
> lines(yn, log(yn))
> a <- predict(opt, newdata = data.frame(g = gf), q = yn, type = "survivor")
> plot(yn, a[,1], type = "l", col = "red", ylim = c(0, 1))
> lines(survfit(cph, newdata = data.frame(g = gf[1])))
> plot(yn, a[,2], type = "l", col = "red", ylim = c(0, 1))
> lines(survfit(cph, newdata = data.frame(g = gf[2])))
> plot(yn, a[,3], type = "l", col = "red", ylim = c(0, 1))
> lines(survfit(cph, newdata = data.frame(g = gf[3])))
> 
> ### h = c(log, bernstein)
> lb <- log_basis(varname = "y", support = c(0, max(y)), ui = "increasing")
> m <- model(response = c(blog = lb, bBern = Bb), shifting = s, todist = "MinExtrVal")
> (cf1 <- coef(opt <- mlt(m, data = mydata)))
Gradient[1] "Mean relative difference: 5.468353e-08"
Hessian:[1] "Mean relative difference: 2.037386e-07"
      log(y)       Bs1(y)       Bs2(y)       Bs3(y)       Bs4(y)       Bs5(y) 
 0.838721035 -0.305720642 -0.002503909 -0.002503894 -0.002503879 -0.002503864 
      Bs6(y)           g2           g3 
 0.275032876  0.764301888  1.068694519 
> ## sample from this model
> sam <- simulate(opt, newdata = data.frame(g = gf), nsim = 100)
> nd <- data.frame(y = unlist(sam), g = rep(gf, length(sam)))
> opt2 <- mlt(m, data = nd)
Gradient[1] TRUE
Hessian:[1] TRUE
> ## visualise
> yn <- mkgrid(Bb, 50)$y
> yn <- yn[yn > 0]
> a <- predict(opt, newdata = data.frame(g = gf[1]), q = yn)
> layout(matrix(1:4, ncol = 2))
> plot(yn, a, type = "l", col = "red")
> lines(yn, log(yn))
> a <- predict(opt, newdata = data.frame(g = gf), q = yn, type = "survivor")
> plot(yn, a[,1], type = "l", col = "red", ylim = c(0, 1))
> lines(survfit(cph, newdata = data.frame(g = gf[1])))
> plot(yn, a[,2], type = "l", col = "red", ylim = c(0, 1))
> lines(survfit(cph, newdata = data.frame(g = gf[2])))
> plot(yn, a[,3], type = "l", col = "red", ylim = c(0, 1))
> lines(survfit(cph, newdata = data.frame(g = gf[3])))
> 
> ### right censoring
> mydata <- data.frame(y = Surv(y, sample(0:1, length(y), replace = TRUE)), g = g)
> coef(opt <- mlt(m, data = mydata))
Gradient[1] TRUE
Hessian:[1] TRUE
    log(y)     Bs1(y)     Bs2(y)     Bs3(y)     Bs4(y)     Bs5(y)     Bs6(y) 
 0.8548918 -0.8701353 -0.7839483 -0.7839483 -0.7839483 -0.7839482 -0.2774455 
        g2         g3 
 0.8692665  1.1418639 
> coef(cph <- coxph(y ~ g, data = mydata))
       g2        g3 
0.7891759 1.0616941 
> 
> ### left censoring
> mydata <- data.frame(y = Surv(y, sample(0:1, length(y), replace = TRUE), type = "left"), g = g)
> coef(opt <- mlt(m, data = mydata))
Gradient[1] TRUE
Hessian:[1] TRUE
     log(y)      Bs1(y)      Bs2(y)      Bs3(y)      Bs4(y)      Bs5(y) 
 0.38199704 -0.04273283  0.97761475  0.97761476  0.97761478  0.97761479 
     Bs6(y)          g2          g3 
 1.19849883  0.33286279  0.53879923 
> 
> ### interval censoring
> Bb <- Bernstein_basis(order = 5, support = c(0, max(y + 1) + .1),
+                       ui = "increasing", var = "y")
> mydata <- data.frame(y = Surv(y, y + 1, sample(0:3, length(y), replace = TRUE), type = "interval"), 
+                      g = g)
> m <- model(response = c(blog = lb, bBern = Bb), shifting = s, todist = "MinExtrVal")
> coef(opt <- mlt(m, data = mydata))
Gradient[1] "Mean relative difference: 5.440672e-08"
Hessian:[1] TRUE
    log(y)     Bs1(y)     Bs2(y)     Bs3(y)     Bs4(y)     Bs5(y)     Bs6(y) 
 0.5103245 -1.2644731  0.1631351  0.1631351  0.1631351  0.1631351  1.1422152 
        g2         g3 
 0.7207465  0.9519261 
> 
> ### uncensored, time-varying coefficints in both groups
> mydata <- data.frame(y = y, g = g)
> m <- model(response = c(blog = lb, bBern = Bb), 
+            interacting = as.basis(~ g, data = mydata),
+            todist = "MinExtrVal")
> coef(opt <- mlt(m, data = mydata))
Note: method with signature 'dsparseMatrix#dsparseMatrix' chosen for function 'kronecker',
 target signature 'dgTMatrix#dgCMatrix'.
 "TsparseMatrix#sparseMatrix" would also be valid
Gradient[1] TRUE
Hessian:[1] "Mean relative difference: 2.365699e-08"
log(y):(Intercept) Bs1(y):(Intercept) Bs2(y):(Intercept) Bs3(y):(Intercept) 
      0.8084027019      -0.0584678409      -0.0584678260      -0.0584678111 
Bs4(y):(Intercept) Bs5(y):(Intercept) Bs6(y):(Intercept)          log(y):g2 
     -0.0584677962      -0.0584677813       0.7438069778      -0.1426389673 
         Bs1(y):g2          Bs2(y):g2          Bs3(y):g2          Bs4(y):g2 
     -0.0009000084       1.2857729470       1.2857729470       1.2857729470 
         Bs5(y):g2          Bs6(y):g2          log(y):g3          Bs1(y):g3 
      1.2857729470       1.0826737862       0.1690790366       1.0337780372 
         Bs2(y):g3          Bs3(y):g3          Bs4(y):g3          Bs5(y):g3 
      1.0337780372       1.0337780372       1.0337780372       2.9139589987 
         Bs6(y):g3 
      2.1116842545 
Warning messages:
1: In spg(par = theta, fn = loglikfct, gr = scorefct, project = "projectLinear",  :
  Unsuccessful convergence.
2: In spg(par = theta, fn = loglikfct, gr = scorefct, project = "projectLinear",  :
  Unsuccessful convergence.
3: In .mlt_fit(object = list(parm = function (beta)  :
  algorithm did not converge
> coef(cph <- coxph(Surv(y, rep(TRUE, nrow(mydata))) ~ g, data = mydata))
      g2       g3 
0.699808 1.022699 
> ## visualize
> a <- predict(opt, newdata = data.frame(g = gf[1]), q = yn)
> layout(matrix(1:4, ncol = 2))
> plot(yn, a, type = "l", col = "red")
> lines(yn, log(yn))
> a <- predict(opt, newdata = data.frame(g = gf), q = yn, type = "survivor")
> plot(yn, a[,1], type = "l", col = "red", ylim = c(0, 1))
> lines(survfit(cph, newdata = data.frame(g = gf[1])))
> plot(yn, a[,2], type = "l", col = "red", ylim = c(0, 1))
> lines(survfit(cph, newdata = data.frame(g = gf[2])))
> plot(yn, a[,3], type = "l", col = "red", ylim = c(0, 1))
> lines(survfit(cph, newdata = data.frame(g = gf[3])))
> 
> 
> proc.time()
   user  system elapsed 
  5.468   0.047   5.508 
