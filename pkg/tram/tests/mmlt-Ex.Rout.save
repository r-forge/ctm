
R version 4.2.1 (2022-06-23) -- "Funny-Looking Kid"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> library("tram")
Loading required package: mlt
Loading required package: basefun
Loading required package: variables
> library("mvtnorm")
> library("multcomp")
Loading required package: survival
Loading required package: TH.data
Loading required package: MASS

Attaching package: 'TH.data'

The following object is masked from 'package:MASS':

    geyser

> 
> options(digits = 2)
> 
> set.seed(25)
> chk <- function(...) all.equal(..., tol = 1e-3, check.attributes = FALSE)
> 
> J <- 4
> N <- 100
> S <- cov2cor(tcrossprod(matrix(runif(J * J), ncol = J)))
> y <- rmvnorm(N, sigma = S)
> u <- as.data.frame(plogis(y))
> x <- runif(N)
> d <- cbind(u, x)
> un <- colnames(d)[1:J]
> 
> m <- lapply(un, function(i)
+     BoxCox(as.formula(paste(i, "~ x")), data = d, bounds = c(0, 1), support = c(0, 1)))
> m$data <- d
> m$formula <- ~ 1
> mm <- do.call("mmlt", m)
> 
> chk(c(logLik(mm)), sum(predict(mm, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> L <- as.array(coef(mm, type = "Lambda"))[,,1]
> chk(as.array(coef(mm, type = "Lambdainv"))[,,1], solve(L))
[1] TRUE
> chk(as.array(coef(mm, type = "Sigma"))[,,1], tcrossprod(solve(L)))
[1] TRUE
> chk(as.array(coef(mm, type = "Cor"))[,,1], cov2cor(tcrossprod(solve(L))))
[1] TRUE
> 
> ### marginal normal
> m$conditional <- FALSE
> mmN <- do.call("mmlt", m)
> 
> chk(logLik(mm), logLik(mmN))
[1] TRUE
> chk(c(logLik(mmN)), sum(predict(mmN, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> 
> cf1 <- do.call("c", lapply(m[1:J], function(x) coef(as.mlt(x))))
> cf2 <- coef(mmN)[1:length(cf1)]
> cbind(cf1, cf2)
           cf1    cf2
Bs1(V1) -3.893 -4.582
Bs2(V1) -0.905 -0.649
Bs3(V1) -0.905 -0.649
Bs4(V1) -0.078 -0.071
Bs5(V1)  0.935  0.750
Bs6(V1)  0.935  0.750
Bs7(V1)  3.951  4.363
x        0.013  0.028
Bs1(V2) -3.536 -3.254
Bs2(V2) -0.465 -1.312
Bs3(V2) -0.250  0.358
Bs4(V2)  0.159  0.358
Bs5(V2)  0.373  0.358
Bs6(V2)  1.912  1.616
Bs7(V2)  3.608  3.588
x        0.363  0.376
Bs1(V3) -3.179 -3.624
Bs2(V3) -0.690 -0.662
Bs3(V3) -0.690 -0.662
Bs4(V3) -0.114  0.214
Bs5(V3)  1.193  1.211
Bs6(V3)  1.193  1.211
Bs7(V3)  3.948  3.408
x        0.395  0.437
Bs1(V4) -3.748 -3.789
Bs2(V4) -0.297 -0.323
Bs3(V4) -0.297 -0.323
Bs4(V4) -0.297  0.016
Bs5(V4)  1.221  1.029
Bs6(V4)  1.221  1.029
Bs7(V4)  3.180  3.436
x        0.148  0.164
> 
> sd1 <- sqrt(do.call("c", lapply(m[1:J], function(x) diag(vcov(as.mlt(x))))))
> sd2 <- sqrt(diag(vcov(mmN)))[1:length(sd1)]
> 
> cbind(sd1, sd2)
         sd1  sd2
Bs1(V1) 2.32 0.87
Bs2(V1) 4.40 0.46
Bs3(V1) 6.42 0.46
Bs4(V1) 7.13 0.82
Bs5(V1) 6.24 0.45
Bs6(V1) 4.29 0.45
Bs7(V1) 2.36 0.86
x       0.34 0.34
Bs1(V2) 1.24 0.48
Bs2(V2) 2.39 0.41
Bs3(V2) 3.72 0.22
Bs4(V2) 4.35 0.22
Bs5(V2) 3.74 0.22
Bs6(V2) 2.36 0.43
Bs7(V2) 1.24 0.55
x       0.34 0.34
Bs1(V3) 1.13 0.48
Bs2(V3) 2.39 0.31
Bs3(V3) 3.87 0.31
Bs4(V3) 4.67 0.54
Bs5(V3) 4.34 0.31
Bs6(V3) 3.05 0.31
Bs7(V3) 1.68 0.51
x       0.34 0.34
Bs1(V4) 1.72 0.59
Bs2(V4) 3.06 0.34
Bs3(V4) 4.15 0.34
Bs4(V4) 4.21 0.61
Bs5(V4) 3.22 0.34
Bs6(V4) 1.81 0.34
Bs7(V4) 0.87 0.57
x       0.34 0.34
> vcov(mmN)["V1.x", "V4.x"]
[1] 0.058
> 
> 
> chk(as.array(coef(mm, type = "Lambda"))[,,1], 
+     as.array(coef(mmN, type = "Lambda"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, type = "Lambdainv"))[,,1], 
+     as.array(coef(mmN, type = "Lambdainv"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, type = "Sigma"))[,,1], 
+     as.array(coef(mmN, type = "Sigma"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, type = "Spearman"))[,,1], 
+     as.array(coef(mmN, type = "Spearman"))[,,1])
[1] TRUE
> 
> chk(predict(mm, newdata = d, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, type = "distribution", log = TRUE))
[1] TRUE
> 
> chk(predict(mm, newdata = d, margins = 1:2, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:2, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "distribution", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:3, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:3, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "distribution", log = TRUE))
[1] TRUE
> 
> chk(sapply(1:J, function(i) predict(mm, margins = i, newdata = d, type = "density", log = TRUE)),
+     sapply(1:J, function(i) predict(mmN, margins = i, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> 
> ### check marginal predictions
> m1 <- m[[1]]
> m2 <- do.call("mmlt", m[-(3:4)])
> m3 <- do.call("mmlt", m[-4])
> 
> chk(c(predict(m1, newdata = d, type = "density", log = TRUE)), 
+     c(predict(mmN, newdata = d, margins = 1, type = "density", log = TRUE)))
[1] "Mean relative difference: 0.17"
> chk(predict(m2, newdata = d, margins = 1:2, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "density", log = TRUE))
[1] "Mean relative difference: 0.14"
> chk(predict(m2, newdata = d, margins = 1:2, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "distribution", log = TRUE))
[1] "Mean relative difference: 0.037"
> chk(predict(m3, newdata = d, margins = 1:3, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "density", log = TRUE))
[1] "Mean relative difference: 0.082"
> chk(predict(m3, newdata = d, margins = 1:3, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "distribution", log = TRUE))
[1] "Mean relative difference: 0.026"
> 
> ### marginal normal, implemented differently
> for (j in 1:J) m[[j]]$todistr$name <- "CarlFriedrich"
> mmN <- do.call("mmlt", m)
> 
> chk(logLik(mm), logLik(mmN))
[1] TRUE
> chk(c(logLik(mmN)), sum(predict(mmN, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> 
> cf1 <- do.call("c", lapply(m[1:J], function(x) coef(as.mlt(x))))
> cf2 <- coef(mmN)[1:length(cf1)]
> cbind(cf1, cf2)
           cf1    cf2
Bs1(V1) -3.893 -4.582
Bs2(V1) -0.905 -0.649
Bs3(V1) -0.905 -0.649
Bs4(V1) -0.078 -0.072
Bs5(V1)  0.935  0.750
Bs6(V1)  0.935  0.750
Bs7(V1)  3.951  4.363
x        0.013  0.028
Bs1(V2) -3.536 -3.254
Bs2(V2) -0.465 -1.311
Bs3(V2) -0.250  0.358
Bs4(V2)  0.159  0.358
Bs5(V2)  0.373  0.358
Bs6(V2)  1.912  1.616
Bs7(V2)  3.608  3.588
x        0.363  0.376
Bs1(V3) -3.179 -3.623
Bs2(V3) -0.690 -0.663
Bs3(V3) -0.690 -0.663
Bs4(V3) -0.114  0.214
Bs5(V3)  1.193  1.211
Bs6(V3)  1.193  1.211
Bs7(V3)  3.948  3.407
x        0.395  0.437
Bs1(V4) -3.748 -3.789
Bs2(V4) -0.297 -0.323
Bs3(V4) -0.297 -0.323
Bs4(V4) -0.297  0.016
Bs5(V4)  1.221  1.029
Bs6(V4)  1.221  1.029
Bs7(V4)  3.180  3.435
x        0.148  0.165
> 
> sd1 <- sqrt(do.call("c", lapply(m[1:J], function(x) diag(vcov(as.mlt(x))))))
> sd2 <- sqrt(diag(vcov(mmN)))[1:length(sd1)]
> 
> cbind(sd1, sd2)
         sd1  sd2
Bs1(V1) 2.32 0.87
Bs2(V1) 4.40 0.46
Bs3(V1) 6.42 0.46
Bs4(V1) 7.13 0.82
Bs5(V1) 6.24 0.45
Bs6(V1) 4.29 0.45
Bs7(V1) 2.36 0.86
x       0.34 0.34
Bs1(V2) 1.24 0.48
Bs2(V2) 2.39 0.41
Bs3(V2) 3.72 0.22
Bs4(V2) 4.35 0.22
Bs5(V2) 3.74 0.22
Bs6(V2) 2.36 0.43
Bs7(V2) 1.24 0.55
x       0.34 0.34
Bs1(V3) 1.13 0.48
Bs2(V3) 2.39 0.31
Bs3(V3) 3.87 0.31
Bs4(V3) 4.67 0.54
Bs5(V3) 4.34 0.31
Bs6(V3) 3.05 0.31
Bs7(V3) 1.68 0.51
x       0.34 0.34
Bs1(V4) 1.72 0.59
Bs2(V4) 3.06 0.34
Bs3(V4) 4.15 0.34
Bs4(V4) 4.21 0.61
Bs5(V4) 3.22 0.34
Bs6(V4) 1.81 0.34
Bs7(V4) 0.87 0.57
x       0.34 0.34
> vcov(mmN)["V1.x", "V4.x"]
[1] 0.058
> 
> chk(as.array(coef(mm, type = "Lambda"))[,,1], 
+     as.array(coef(mmN, type = "Lambda"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, type = "Lambdainv"))[,,1], 
+     as.array(coef(mmN, type = "Lambdainv"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, type = "Sigma"))[,,1], 
+     as.array(coef(mmN, type = "Sigma"))[,,1])
[1] TRUE
> chk(as.array(coef(mm, type = "Spearman"))[,,1], 
+     as.array(coef(mmN, type = "Spearman"))[,,1])
[1] TRUE
> 
> chk(predict(mm, newdata = d, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, type = "distribution", log = TRUE))
[1] TRUE
> 
> chk(predict(mm, newdata = d, margins = 1:2, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:2, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "distribution", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:3, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "density", log = TRUE))
[1] TRUE
> chk(predict(mm, newdata = d, margins = 1:3, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "distribution", log = TRUE))
[1] TRUE
> 
> chk(sapply(1:J, function(i) predict(mm, margins = i, newdata = d, type = "density", log = TRUE)),
+     sapply(1:J, function(i) predict(mmN, margins = i, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> 
> ### marginal Colr models
> m <- lapply(un, function(i)
+     Colr(as.formula(paste(i, "~ x")), data = d, bounds = c(0, 1), support = c(0, 1)))
> m$data <- d
> m$formula <- ~ 1
> mmC <- do.call("mmlt", m)
> 
> chk(c(logLik(mmC)), sum(predict(mmC, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> logLik(mmC)
'log Lik.' 310 (df=38)
> 
> ### conditional models
> m <- lapply(un, function(i)
+     BoxCox(as.formula(paste(i, "~ x")), data = d, bounds = c(0, 1), support = c(0, 1)))
> m$data <- d
> m$formula <- ~ x
> mm <- do.call("mmlt", m)
> 
> chk(c(logLik(mm)), sum(predict(mm, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> L <- as.array(coef(mm, newdata = d, type = "Lambda"))[,,1]
> chk(as.array(coef(mm, newdata = d, type = "Lambdainv"))[,,1], solve(L))
[1] TRUE
> chk(as.array(coef(mm, newdata = d, type = "Sigma"))[,,1], tcrossprod(solve(L)))
[1] TRUE
> chk(as.array(coef(mm, newdata = d, type = "Cor"))[,,1], cov2cor(tcrossprod(solve(L))))
[1] TRUE
> 
> ### with marginal parameterisation
> m$conditional <- FALSE
> mmN <- do.call("mmlt", m)
> 
> chk(logLik(mm), logLik(mmN))
[1] "Mean relative difference: 0.0037"
> chk(c(logLik(mmN)), sum(predict(mmN, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> 
> chk(as.array(coef(mm, newdata = d, type = "Lambda"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Lambda"))[,,1])
[1] "Mean relative difference: 0.015"
> chk(as.array(coef(mm, newdata = d, type = "Lambdainv"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Lambdainv"))[,,1])
[1] "Mean relative difference: 0.036"
> chk(as.array(coef(mm, newdata = d, type = "Sigma"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Sigma"))[,,1])
[1] "Mean relative difference: 0.064"
> chk(as.array(coef(mm, newdata = d, type = "Spearman"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Spearman"))[,,1])
[1] "Mean relative difference: 0.028"
> 
> chk(predict(mm, newdata = d, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, type = "density", log = TRUE))
[1] "Mean relative difference: 0.026"
> chk(predict(mm, newdata = d, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, type = "distribution", log = TRUE))
[1] "Mean relative difference: 0.013"
> 
> chk(predict(mm, newdata = d, margins = 1:2, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "density", log = TRUE))
[1] "Mean relative difference: 0.026"
> chk(predict(mm, newdata = d, margins = 1:2, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "distribution", log = TRUE))
[1] "Mean relative difference: 0.0089"
> chk(predict(mm, newdata = d, margins = 1:3, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "density", log = TRUE))
[1] "Mean relative difference: 0.034"
> chk(predict(mm, newdata = d, margins = 1:3, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "distribution", log = TRUE))
[1] "Mean relative difference: 0.014"
> 
> chk(sapply(1:J, function(i) predict(mm, margins = i, newdata = d, type = "density", log = TRUE)),
+     sapply(1:J, function(i) predict(mmN, margins = i, newdata = d, type = "density", log = TRUE)))
[1] "Mean relative difference: 0.047"
> 
> ### implemented differently
> for (j in 1:J) m[[j]]$todistr$name <- "CarlFriedrich"
> mmN <- do.call("mmlt", m)
> 
> chk(logLik(mm), logLik(mmN))
[1] "Mean relative difference: 0.0037"
> chk(c(logLik(mmN)), sum(predict(mmN, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> 
> chk(as.array(coef(mm, newdata = d, type = "Lambda"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Lambda"))[,,1])
[1] "Mean relative difference: 0.015"
> chk(as.array(coef(mm, newdata = d, type = "Lambdainv"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Lambdainv"))[,,1])
[1] "Mean relative difference: 0.036"
> chk(as.array(coef(mm, newdata = d, type = "Sigma"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Sigma"))[,,1])
[1] "Mean relative difference: 0.064"
> chk(as.array(coef(mm, newdata = d, type = "Spearman"))[,,1], 
+     as.array(coef(mmN, newdata = d, type = "Spearman"))[,,1])
[1] "Mean relative difference: 0.028"
> 
> chk(predict(mm, newdata = d, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, type = "density", log = TRUE))
[1] "Mean relative difference: 0.026"
> chk(predict(mm, newdata = d, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, type = "distribution", log = TRUE))
[1] "Mean relative difference: 0.013"
> 
> chk(predict(mm, newdata = d, margins = 1:2, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "density", log = TRUE))
[1] "Mean relative difference: 0.026"
> chk(predict(mm, newdata = d, margins = 1:2, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:2, type = "distribution", log = TRUE))
[1] "Mean relative difference: 0.0089"
> chk(predict(mm, newdata = d, margins = 1:3, type = "density", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "density", log = TRUE))
[1] "Mean relative difference: 0.034"
> chk(predict(mm, newdata = d, margins = 1:3, type = "distribution", log = TRUE), 
+     predict(mmN, newdata = d, margins = 1:3, type = "distribution", log = TRUE))
[1] "Mean relative difference: 0.014"
> 
> chk(sapply(1:J, function(i) predict(mm, margins = i, newdata = d, type = "density", log = TRUE)),
+     sapply(1:J, function(i) predict(mmN, margins = i, newdata = d, type = "density", log = TRUE)))
[1] "Mean relative difference: 0.047"
> 
> ### conditional Colr
> m <- lapply(un, function(i)
+     Colr(as.formula(paste(i, "~ x")), data = d, bounds = c(0, 1), support = c(0, 1)))
> m$data <- d
> m$formula <- ~ x
> mmC <- do.call("mmlt", m)
> 
> chk(c(logLik(mmC)), sum(predict(mmC, newdata = d, type = "density", log = TRUE)))
[1] TRUE
> logLik(mmC)
'log Lik.' 311 (df=44)
> 
> ##### FIRST SCENARIO: CONSTANT LAMBDA #####
> ll <- numeric(50)
> p <- 3
> X <- matrix(runif(N * p), ncol = p)
> m1 <- 1 + X %*% c(2, 1, 1)
> m2 <- 1 + X %*% c(1, 2, 1)
> lb <- (off <- 0.5) + X %*% (cf <- c(0, 2, 0))
> d <- data.frame(X)
> Y <- matrix(NA, nrow = N, ncol = 2)
> colnames(Y) <- c("Y1", "Y2")
> 
> cr <- numeric(N)
> for (i in 1:N) {
+   Si <- diag(2)
+   Si[1,2] <- Si[2,1] <- .5
+   cr[i] <- cov2cor(Si)[2,1]
+   
+   Y[i,] <- rmvnorm(1, mean = c(m1[i], m2[i]), sigma = Si)
+ }
> 
> 
> ##### only BoxCox margins: ##### 
> d <- cbind(d, Y)
> b1 <- as.mlt(Lm(Y1 ~ X1 + X2 + X3, data = d))
> b2 <- as.mlt(Lm(Y2 ~ X1 + X2 + X3, data = d))
> 
> ## constant correlations. expect identical logliks and lambda parameters
> mm01 <- mmlt(b1, b2, formula = ~ 1, data = d)
> mm02 <- mmlt(b2, b1, formula = ~ 1, data = d)
> 
> chk(logLik(mm01), logLik(mm02))
[1] TRUE
> 
> chk(c(coef(mm01)["Y2.Y1.(Intercept)"]), 
+     c(coef(mm02)["Y1.Y2.(Intercept)"]))
[1] TRUE
> 
> ## checking gradients
> chk(c(numDeriv::grad(mm01$ll, mm02$par)),
+     c(mm01$sc(mm02$par)))
[1] TRUE
> 
> ## predicting marginal distributions and comparing across models with constant lambda
> predict(mm01, newdata = d[1:5,], q = -2:2, 
+         margins = 1, type = "distribution")
       
Y1         [,1]    [,2]    [,3]    [,4]    [,5]
     -2 5.7e-05 9.6e-05 7.5e-07 7.8e-06 9.7e-08
     -1 2.6e-03 3.8e-03 8.8e-05 5.6e-04 1.7e-05
      0 4.1e-02 5.4e-02 3.6e-03 1.4e-02 1.0e-03
      1 2.5e-01 2.9e-01 5.2e-02 1.3e-01 2.2e-02
      2 6.5e-01 7.0e-01 2.9e-01 4.7e-01 1.7e-01
> predict(mm02, newdata = d[1:5,], q = -2:2, 
+         margins = 2, type = "distribution")
       
Y1         [,1]    [,2]    [,3]    [,4]    [,5]
     -2 5.7e-05 9.6e-05 7.5e-07 7.8e-06 9.7e-08
     -1 2.6e-03 3.8e-03 8.8e-05 5.6e-04 1.7e-05
      0 4.1e-02 5.4e-02 3.6e-03 1.4e-02 1.0e-03
      1 2.5e-01 2.9e-01 5.2e-02 1.3e-01 2.2e-02
      2 6.5e-01 7.0e-01 2.9e-01 4.7e-01 1.7e-01
> 
> ## expect correlations to be the same for the model with constant lambdas
> chk(c(coef(mm01, newdata = d[1:5,], type = "Cor")), 
+     c(coef(mm02, newdata = d[1:5,], type = "Cor")))
[1] TRUE
> 
> 
> ##### mix of BoxCox and Colr margins: ##### 
> d$Y1 <- (d$Y1 - min(d$Y1))/(max(d$Y1) - min(d$Y1))
> 
> b1 <- as.mlt(Colr(Y1 ~ X1 + X2 + X3, data = d, order = 1))
> b2 <- as.mlt(Lm(Y2 ~ X1 + X2 + X3, data = d))
> 
> mm01 <- mmlt(b1, b2, formula = ~ 1, data = d)
> mm02 <- mmlt(b2, b1, formula = ~ 1, data = d)
> 
> chk(logLik(mm01), logLik(mm02))
[1] TRUE
> 
> ### model is marginal, so expect same marginal coeff
> cf1 <- coef(mm01)
> cf1 <- cf1[-length(cf1)]
> cf2 <- coef(mm02)
> cf2 <- cf2[names(cf1)]
> chk(cf1, cf2)
[1] TRUE
> 
> ## checking gradient
> chk(c(numDeriv::grad(mm01$ll, coef(mm01))), c(mm01$sc(coef(mm01))))
[1] TRUE
> chk(c(numDeriv::grad(mm02$ll, coef(mm02))), c(mm02$sc(coef(mm02)))) 
[1] TRUE
> 
> ##### SECOND SCENARIO: COVARIATE DEPENDENT LAMBDA #####
> ll <- numeric(50)
> 
> X <- matrix(runif(N * p), ncol = p)
> m1 <- 1 + X %*% c(2, 1, 1)
> m2 <- 1 + X %*% c(1, 2, 1)
> lb <- (off <- 0.5) + X %*% (cf <- c(0, 2, 0))
> d <- data.frame(X)
> Y <- matrix(NA, nrow = N, ncol = 2)
> colnames(Y) <- c("Y1", "Y2")
> 
> cr <- numeric(N)
> for (i in 1:N) {
+   L <- diag(2)
+   L[2,1] <- lb[i]
+   Si <- solve(L) %*% t(solve(L))
+   cr[i] <- cov2cor(Si)[2,1]
+   
+   Y[i,] <- rmvnorm(1, mean = c(m1[i], m2[i]), sigma = Si)
+ }
> 
> 
> ##### only BoxCox margins: ##### 
> d <- cbind(d, Y)
> b1 <- as.mlt(Lm(Y1 ~ X1 + X2 + X3, data = d))
> b2 <- as.mlt(Lm(Y2 ~ X1 + X2 + X3, data = d))
> 
> ## constant correlations. expect identical logliks and lambda parameters
> mm01 <- mmlt(b1, b2, formula = ~ 1, data = d)
> mm02 <- mmlt(b2, b1, formula = ~ 1, data = d)
> 
> chk(logLik(mm01), logLik(mm02))
[1] TRUE
> 
> ## x-dependent correlations. expect slightly different logliks
> mm1 <- mmlt(b1, b2, formula = ~ X1 + X2 + X3, data = d)
Warning message:
In c.basis(bresponse = function (data, deriv = 0L)  :
  more than one basis contains an intercept term
> mm2 <- mmlt(b2, b1, formula = ~ X1 + X2 + X3, data = d)
Warning message:
In c.basis(bresponse = function (data, deriv = 0L)  :
  more than one basis contains an intercept term
> 
> logLik(mm1)
'log Lik.' -265 (df=14)
> logLik(mm2)
'log Lik.' -270 (df=14)
> 
> ## checking gradients
> chk(c(numDeriv::grad(mm01$ll, mm02$par)),c(mm01$sc(mm02$par)))
[1] TRUE
> chk(c(numDeriv::grad(mm1$ll, mm2$par)),c(mm1$sc(mm2$par)))
[1] TRUE
> 
> ### BUT
> mm1 <- mmlt(b1, b2, formula = ~ X1 + X2 + X3, data = d, conditional = FALSE)
> mm2 <- mmlt(b2, b1, formula = ~ X1 + X2 + X3, data = d, conditional = FALSE)
> 
> logLik(mm1)
'log Lik.' -266 (df=14)
> logLik(mm2)
'log Lik.' -266 (df=14)
> 
> ## predicting marginal distributions and comparing across models with constant lambda
> x <- 0:4 / 4
> nd <- expand.grid(X1 = x, X2 = x, X3 = x)
> predict(mm01, newdata = nd[1:5,], q = -2:2, 
+         margins = 1, type = "distribution")
       
Y1        [,1]    [,2]    [,3]    [,4]    [,5]
     -2 0.0044 0.00037 1.9e-05 5.4e-07 9.0e-09
     -1 0.0641 0.01149 1.2e-03 7.9e-05 2.9e-06
      0 0.3360 0.11982 2.7e-02 3.7e-03 3.0e-04
      1 0.7501 0.46898 2.0e-01 5.7e-02 9.8e-03
      2 0.9619 0.84618 6.1e-01 3.1e-01 1.1e-01
> predict(mm02, newdata = nd[1:5,], q = -2:2, 
+         margins = 2, type = "distribution")
       
Y1        [,1]    [,2]    [,3]    [,4]    [,5]
     -2 0.0044 0.00037 1.9e-05 5.4e-07 9.0e-09
     -1 0.0641 0.01149 1.2e-03 7.9e-05 2.9e-06
      0 0.3360 0.11982 2.7e-02 3.7e-03 3.0e-04
      1 0.7501 0.46897 2.0e-01 5.7e-02 9.8e-03
      2 0.9619 0.84618 6.1e-01 3.1e-01 1.1e-01
> 
> predict(mm1, newdata = nd[1:5,], q = -2:2, 
+         margins = 1, type = "distribution")
       
Y1       [,1]    [,2]    [,3]    [,4]    [,5]
     -2 0.004 0.00033 1.6e-05 4.4e-07 7.1e-09
     -1 0.063 0.01122 1.2e-03 7.5e-05 2.7e-06
      0 0.343 0.12312 2.8e-02 3.8e-03 3.1e-04
      1 0.764 0.48557 2.1e-01 6.1e-02 1.1e-02
      2 0.967 0.86152 6.3e-01 3.4e-01 1.2e-01
> predict(mm2, newdata = nd[1:5,], q = -2:2, 
+         margins = 2, type = "distribution")
       
Y1       [,1]    [,2]    [,3]    [,4]    [,5]
     -2 0.004 0.00033 1.6e-05 4.4e-07 7.1e-09
     -1 0.063 0.01122 1.2e-03 7.5e-05 2.7e-06
      0 0.343 0.12312 2.8e-02 3.8e-03 3.1e-04
      1 0.764 0.48557 2.1e-01 6.1e-02 1.1e-02
      2 0.967 0.86152 6.3e-01 3.4e-01 1.2e-01
> 
> ## expect correlations to be the same for the model with constant lambdas
> chk(c(coef(mm01, newdata = nd[1:5,], type = "Cor")), 
+     c(coef(mm02, newdata = nd[1:5,], type = "Cor")))
[1] TRUE
> 
> ## correlations for models with x-dependent lambda
> c(coef(mm1, newdata = nd[1:5,], type = "Cor"))
[1] -0.74 -0.71 -0.68 -0.65 -0.60
> c(coef(mm2, newdata = nd[1:5,], type = "Cor"))
[1] -0.74 -0.71 -0.68 -0.65 -0.60
> 
> 
> ##### mix of BoxCox and Colr margins: ##### 
> d$Y1 <- (d$Y1 - min(d$Y1))/(max(d$Y1) - min(d$Y1))
> 
> b1 <- as.mlt(Colr(Y1 ~ X1 + X2 + X3, data = d, order = 1))
> b2 <- as.mlt(Lm(Y2 ~ X1 + X2 + X3, data = d))
> 
> mm01 <- mmlt(b1, b2, formula = ~ 1, data = d)
> mm02 <- mmlt(b2, b1, formula = ~ 1, data = d)
> 
> chk(logLik(mm01), logLik(mm02))
[1] TRUE
> 
> coef(b1)
Bs1(Y1) Bs2(Y1)      X1      X2      X3 
    1.7     8.3    -5.2    -2.0    -2.7 
> coef(b2)
(Intercept)          Y2          X1          X2          X3 
     -1.367       0.648       0.041       1.331       0.070 
> coef(mm01)
       Y1.Bs1(Y1)        Y1.Bs2(Y1)             Y1.X1             Y1.X2 
            1.638             8.273            -5.117            -2.056 
            Y1.X3    Y2.(Intercept)             Y2.Y2             Y2.X1 
           -2.626            -1.405             0.643             0.106 
            Y2.X2             Y2.X3 Y2.Y1.(Intercept) 
            1.221             0.083             1.272 
> coef(mm02)
   Y2.(Intercept)             Y2.Y2             Y2.X1             Y2.X2 
           -1.405             0.643             0.106             1.221 
            Y2.X3        Y1.Bs1(Y1)        Y1.Bs2(Y1)             Y1.X1 
            0.083             1.638             8.273            -5.117 
            Y1.X2             Y1.X3 Y1.Y2.(Intercept) 
           -2.056            -2.626             1.272 
> # remember that: lb <- (off <- 0.5) + X %*% (cf <- c(0, 2, 0))
> 
> 
> ## checking gradient
> chk(c(numDeriv::grad(mm01$ll, coef(mm01))),c(mm01$sc(coef(mm01))))
[1] TRUE
> chk(c(numDeriv::grad(mm02$ll, coef(mm02))),c(mm02$sc(coef(mm02))))
[1] TRUE
> 
> ## covariate-dependent Lambda
> mm1 <- mmlt(b1, b2, formula = ~ X1 + X2 + X3, data = d)
> mm2 <- mmlt(b2, b1, formula = ~ X1 + X2 + X3, data = d)
> logLik(mm1)
'log Lik.' -89 (df=14)
> logLik(mm2)
'log Lik.' -89 (df=14)
> 
> coef(b1)
Bs1(Y1) Bs2(Y1)      X1      X2      X3 
    1.7     8.3    -5.2    -2.0    -2.7 
> coef(b2)
(Intercept)          Y2          X1          X2          X3 
     -1.367       0.648       0.041       1.331       0.070 
> coef(mm1)
       Y1.Bs1(Y1)        Y1.Bs2(Y1)             Y1.X1             Y1.X2 
           1.7073            8.4990           -5.1735           -2.2671 
            Y1.X3    Y2.(Intercept)             Y2.Y2             Y2.X1 
          -2.6038           -1.3282            0.6225            0.0450 
            Y2.X2             Y2.X3 Y2.Y1.(Intercept)          Y2.Y1.X1 
           1.3406            0.0099            1.1577           -0.3013 
         Y2.Y1.X2          Y2.Y1.X3 
           1.3577           -0.6458 
> coef(mm2)
   Y2.(Intercept)             Y2.Y2             Y2.X1             Y2.X2 
          -1.3282            0.6225            0.0450            1.3406 
            Y2.X3        Y1.Bs1(Y1)        Y1.Bs2(Y1)             Y1.X1 
           0.0099            1.7073            8.4990           -5.1735 
            Y1.X2             Y1.X3 Y1.Y2.(Intercept)          Y1.Y2.X1 
          -2.2671           -2.6038            1.1577           -0.3013 
         Y1.Y2.X2          Y1.Y2.X3 
           1.3577           -0.6458 
> # remember that: lb <- (off <- 0.5) + X %*% (cf <- c(0, 2, 0))
> 
> ## checking gradient for diag = TRUE
> chk(c(numDeriv::grad(mm1$ll, coef(mm1))),c(mm1$sc(coef(mm1))))
[1] TRUE
> chk(c(numDeriv::grad(mm2$ll, coef(mm2))),c(mm2$sc(coef(mm2))))
[1] TRUE
> 
> ### very simple checks with marginal Lm models
> J <- 4
> S <- cov2cor(tcrossprod(matrix(runif(J * J), ncol = J)))
> x <- matrix(runif(N*2), ncol = 2)
> 
> y <- x %*% matrix(c(1, -1, -.5, .5, -.2, .2, .3, -.3), nrow = 2) + rmvnorm(N, sigma = S)
> d <- data.frame(y = y, x = x)
> 
> m1 <- Lm(y.1 ~ x.1 + x.2, data = d)
> m2 <- Lm(y.2 ~ x.1 + x.2, data = d)
> m3 <- Lm(y.3 ~ x.1 + x.2, data = d)
> m4 <- Lm(y.4 ~ x.1 + x.2, data = d)
> 
> ## simple formula
> mc01 <- mmlt(m1, m2, m3, m4, formula = ~ 1, data = d, conditional = FALSE)
> 
> cf <- coef(mc01)
> vr <- diag(vcov(mc01))
> i <- grep("x", names(cf))
> 
> ### same results
> ret <- cbind(c(coef(m1), coef(m2), coef(m3), coef(m4)),
+              cf[i],
+              c(diag(vcov(m1)), diag(vcov(m2)), diag(vcov(m3)), diag(vcov(m4))),
+              vr[i])
> ret
      [,1]   [,2] [,3] [,4]
x.1  1.549  1.559 0.13 0.13
x.2 -0.818 -0.826 0.11 0.11
x.1 -0.701 -0.707 0.12 0.12
x.2  0.856  0.862 0.11 0.11
x.1 -0.022 -0.026 0.11 0.11
x.2  0.580  0.585 0.11 0.11
x.1  0.863  0.867 0.12 0.11
x.2 -0.052 -0.054 0.11 0.11
> 
> vc <- vcov(mc01)
> i <- grep("x.1", colnames(vc))
> vc[i,i]
        y.1.x.1 y.2.x.1 y.3.x.1 y.4.x.1
y.1.x.1   0.125   0.061   0.101   0.106
y.2.x.1   0.061   0.116   0.098   0.073
y.3.x.1   0.101   0.098   0.113   0.103
y.4.x.1   0.110   0.072   0.103   0.114
> 
> summary(g1 <- glht(mmm(m1 = as.mlt(m1), m2 = as.mlt(m2), m3 = as.mlt(m3), m4 = as.mlt(m4)), mlf("x.1 = 0")))

	 Simultaneous Tests for General Linear Hypotheses

Linear Hypotheses:
             Estimate Std. Error z value Pr(>|z|)    
m1: x.1 == 0   1.5490     0.3543    4.37   <0.001 ***
m2: x.1 == 0  -0.7006     0.3405   -2.06    0.088 .  
m3: x.1 == 0  -0.0224     0.3369   -0.07    1.000    
m4: x.1 == 0   0.8633     0.3424    2.52    0.028 *  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
(Adjusted p values reported -- single-step method)

> 
> summary(g2 <- glht(mc01, c("y.1.x.1 = 0", "y.2.x.1 = 0", "y.3.x.1 = 0", "y.4.x.1 = 0")))

	 Simultaneous Tests for General Linear Hypotheses

Fit: mmlt(m1, m2, m3, m4, formula = ~1, data = d, conditional = FALSE)

Linear Hypotheses:
             Estimate Std. Error z value Pr(>|z|)    
y.1.x.1 == 0   1.5585     0.3541    4.40   <0.001 ***
y.2.x.1 == 0  -0.7073     0.3405   -2.08    0.084 .  
y.3.x.1 == 0  -0.0262     0.3369   -0.08    1.000    
y.4.x.1 == 0   0.8667     0.3383    2.56    0.025 *  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
(Adjusted p values reported -- single-step method)

> 
> vcov(g1)
        m1: x.1 m2: x.1 m3: x.1 m4: x.1
m1: x.1   0.125   0.064   0.102   0.110
m2: x.1   0.064   0.116   0.098   0.075
m3: x.1   0.102   0.098   0.113   0.104
m4: x.1   0.110   0.075   0.104   0.117
> vcov(g2)
        y.1.x.1 y.2.x.1 y.3.x.1 y.4.x.1
y.1.x.1   0.125   0.061   0.101   0.106
y.2.x.1   0.061   0.116   0.098   0.073
y.3.x.1   0.101   0.098   0.113   0.103
y.4.x.1   0.110   0.072   0.103   0.114
> 
> 
> #### check density
> Shat <- as.array(coef(mc01, type = "Cor"))[,,1]
> 
> int <- cf[paste("y", 1:J, "(Intercept)", sep = ".")]
> fct <- cf[paste("y", 1:J, "y", 1:J, sep = ".")]
> 
> d1 <- sapply(1:N, function(i) dmvnorm(int + fct * y[i,], mean = x[i,,drop = FALSE] %*% matrix(ret[,1], nrow = 2), sigma = Shat, log = TRUE))
> d2 <- predict(mc01, newdata = d, type = "density", log = TRUE)
> 
> chk(c(d1), c(d2))
[1] "Mean relative difference: 0.16"
> 
> chk(c(logLik(mmlt(m1, m2, m3, m4, formula = ~ 1, data = d))),
+     c(logLik(mc01)))
[1] TRUE
> chk(c(logLik(mc01)),
+     sum(d2))
[1] TRUE
> 
> 
> proc.time()
   user  system elapsed 
 15.374   0.088  15.450 
