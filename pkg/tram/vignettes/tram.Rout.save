
> set.seed(290875)

> pkgs <- sapply(c("tram", "survival", "MASS", "lattice", 
+     "mlbench", "multcomp", "ordinal", "colorspace", "quantreg", 
+     "trtf", "ATR"), re .... [TRUNCATED] 
Loading required package: tram
Loading required package: mlt
Loading required package: basefun
Loading required package: variables
Loading required package: mvtnorm
Loading required package: survival
Loading required package: MASS
Loading required package: lattice
Loading required package: mlbench
Loading required package: multcomp
Loading required package: TH.data

Attaching package: ‘TH.data’

The following object is masked from ‘package:MASS’:

    geyser

Loading required package: ordinal
Loading required package: colorspace
Loading required package: quantreg
Loading required package: SparseM

Attaching package: ‘quantreg’

The following object is masked from ‘package:survival’:

    untangle.specials

Loading required package: trtf
Loading required package: partykit
Loading required package: grid

Attaching package: ‘grid’

The following object is masked from ‘package:variables’:

    unit

Loading required package: libcoin
Loading required package: ATR

> trellis.par.set(list(plot.symbol = list(col = 1, pch = 20, 
+     cex = 0.7), box.rectangle = list(col = 1), box.umbrella = list(lty = 1, 
+     col .... [TRUNCATED] 
Warning in trellis.par.set(list(plot.symbol = list(col = 1, pch = 20, cex = 0.7),  :
  Note: The default device has been opened to honour attempt to modify trellis settings

> ltheme <- canonical.theme(color = FALSE)

> ltheme$strip.background$col <- "transparent"

> lattice.options(default.theme = ltheme)

> knitr::opts_chunk$set(echo = TRUE, results = "markup", 
+     error = FALSE, warning = FALSE, message = FALSE, tidy = FALSE, 
+     cache = FALSE, s .... [TRUNCATED] 

> knitr::render_sweave()

> knitr::set_header(highlight = "")

> options(prompt = "R> ", continue = "+  ", useFancyQuotes = FALSE)

> options(width = 75, digits = 4)

> library("colorspace")

> col <- diverge_hcl(2, h = c(246, 40), c = 96, l = c(65, 
+     90))

> fill <- diverge_hcl(2, h = c(246, 40), c = 96, l = c(65, 
+     90), alpha = 0.3)

> year <- substr(packageDescription("tram")$Date, 1, 
+     4)

> version <- packageDescription("tram")$Version

> if (any(!pkgs)) {
+     cat(paste("Package(s)", paste(names(pkgs)[!pkgs], collapse = ", "), 
+         "not available, stop processing.", "\\end{doc ..." ... [TRUNCATED] 

> if (!interactive() && .Platform$OS.type != "unix") {
+     cat(paste("Vignette only compiled under Unix alikes.", "\\end{document}\n"))
+     knitr: .... [TRUNCATED] 

> data("BostonHousing2", package = "mlbench")

> lm_BH <- lm(cmedv ~ crim + zn + indus + chas + nox + 
+     rm + age + dis + rad + tax + ptratio + b + lstat, data = BostonHousing2)

> BostonHousing2$rad <- as.numeric(BostonHousing2$rad)

> BostonHousing2$tax <- as.numeric(BostonHousing2$tax)

> Lm_BH_1 <- Lm(cmedv ~ crim + zn + indus + chas + nox + 
+     rm + age + dis + rad + tax + ptratio + b + lstat, data = BostonHousing2)

> logLik(lm_BH)
'log Lik.' -1494 (df=15)

> logLik(Lm_BH_1)
'log Lik.' -1494 (df=15)

> coef(lm_BH)
(Intercept)        crim          zn       indus       chas1         nox 
  3.637e+01  -1.062e-01   4.772e-02   2.325e-02   2.692e+00  -1.774e+01 
         rm         age         dis         rad         tax     ptratio 
  3.789e+00   5.749e-04  -1.502e+00   3.038e-01  -1.270e-02  -9.239e-01 
          b       lstat 
  9.228e-03  -5.307e-01 

> coef(Lm_BH_1, as.lm = TRUE)
(Intercept)        crim          zn       indus       chas1         nox 
  3.637e+01  -1.062e-01   4.772e-02   2.324e-02   2.692e+00  -1.774e+01 
         rm         age         dis         rad         tax     ptratio 
  3.790e+00   5.731e-04  -1.502e+00   3.037e-01  -1.270e-02  -9.239e-01 
          b       lstat 
  9.229e-03  -5.307e-01 
attr(,"scale")
cmedv 
4.637 

> summary(lm_BH)$sigma
[1] 4.703

> 1/coef(Lm_BH_1, with_baseline = TRUE)["cmedv"]
cmedv 
4.637 

> BostonHousing2$y <- with(BostonHousing2, Surv(cmedv, 
+     cmedv < 50))

> Lm_BH_2 <- Lm(y ~ crim + zn + indus + chas + nox + 
+     rm + age + dis + rad + tax + ptratio + b + lstat, data = BostonHousing2)

> logLik(Lm_BH_2)
'log Lik.' -1496 (df=15)

> Lm_BH_3 <- Lm(y | 0 + chas ~ crim + zn + indus + nox + 
+     rm + age + dis + rad + tax + ptratio + b + lstat, data = BostonHousing2)

> logLik(Lm_BH_3)
'log Lik.' -1478 (df=16)

> 1/coef(Lm_BH_3, with_baseline = TRUE)[c(2, 4)]
y:chas0 y:chas1 
  4.133   7.157 

> summary(glht(as.mlt(Lm_BH_3), linfct = c("y:chas0 - y:chas1 = 0")))

	 Simultaneous Tests for General Linear Hypotheses

Fit: Lm(formula = y | 0 + chas ~ crim + zn + indus + nox + rm + age + 
    dis + rad + tax + ptratio + b + lstat, data = BostonHousing2)

Linear Hypotheses:
                       Estimate Std. Error z value Pr(>|z|)    
y:chas0 - y:chas1 == 0    0.102      0.015    6.83  8.5e-12 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
(Adjusted p values reported -- single-step method)


> Lm_BH_4 <- Lm(y | 0 + chas + crim + zn + indus + nox + 
+     rm + age + dis + rad + tax + ptratio + b + lstat ~ 0, data = BostonHousing2)
Warning in model.matrix.box_bases(object = list(iresponse = function (data,  :
  use scale = TRUE in as.basis.formula with sumcontr = TRUE
Warning in model.matrix.box_bases(object = list(iresponse = function (data,  :
  use scale = TRUE in as.basis.formula with sumcontr = TRUE
Warning in model.matrix.box_bases(object = list(iresponse = function (data,  :
  use scale = TRUE in as.basis.formula with sumcontr = TRUE
Warning in model.matrix.box_bases(object = list(iresponse = function (data,  :
  use scale = TRUE in as.basis.formula with sumcontr = TRUE
Warning in model.matrix.box_bases(object = list(iresponse = function (data,  :
  use scale = TRUE in as.basis.formula with sumcontr = TRUE
Warning in model.matrix.box_bases(object = list(iresponse = function (data,  :
  use scale = TRUE in as.basis.formula with sumcontr = TRUE
Warning in model.matrix.box_bases(object = list(iresponse = function (data,  :
  use scale = TRUE in as.basis.formula with sumcontr = TRUE

> logLik(Lm_BH_4)
'log Lik.' -1310 (df=28)

> BC_BH_1 <- BoxCox(y ~ chas + crim + zn + indus + nox + 
+     rm + age + dis + rad + tax + ptratio + b + lstat, data = BostonHousing2)

> logLik(BC_BH_1)
'log Lik.' -1320 (df=20)

> nd <- model.frame(BC_BH_1)[1, -1, drop = FALSE]

> plot(BC_BH_1, which = "baseline only", newdata = nd, 
+     col = col, confidence = "interval", fill = fill, lwd = 2, 
+     xlab = "Median Value",  .... [TRUNCATED] 

> BC_BH_2 <- BoxCox(y | 0 + chas ~ crim + zn + indus + 
+     nox + rm + age + dis + rad + tax + ptratio + b + lstat, data = BostonHousing2)

> logLik(BC_BH_2)
'log Lik.' -1316 (df=26)

> nd <- model.frame(BC_BH_2)[1:2, -1]

> nd$chas <- factor(c("0", "1"))

> plot(BC_BH_2, which = "baseline only", newdata = nd, 
+     col = col, confidence = "interval", fill = fill, lwd = 2, 
+     xlab = "Median Value",  .... [TRUNCATED] 

> legend("bottomright", lty = 1, col = col, title = "Near Charles River", 
+     legend = c("no", "yes"), bty = "n")

> plot(Lm_BH_3, which = "baseline only", newdata = nd, 
+     col = col, confidence = "interval", fill = fill, lwd = 2)

> legend("bottomright", lty = 1, col = col, title = "Near Charles River", 
+     legend = c("no", "yes"), bty = "n")

> Colr_BH_1 <- Colr(y | 0 + chas ~ crim + zn + indus + 
+     nox + rm + age + dis + rad + tax + ptratio + b + lstat, data = BostonHousing2)

> logLik(Colr_BH_1)
'log Lik.' -1291 (df=26)

> round(cbind(exp(coef(Colr_BH_1)), exp(confint(Colr_BH_1))), 
+     3)
                  2.5 %    97.5 %
crim       1.084  1.055     1.115
zn         0.990  0.980     0.999
indus      0.976  0.936     1.017
nox     1162.327 63.090 21414.046
rm         0.218  0.142     0.334
age        1.010  1.000     1.020
dis        1.660  1.425     1.935
rad        0.884  0.842     0.928
tax        1.007  1.004     1.009
ptratio    1.495  1.360     1.643
b          0.994  0.992     0.996
lstat      1.322  1.256     1.393

> nd <- BostonHousing2

> nd$y <- NULL

> q <- 0:50

> d <- predict(Colr_BH_1, newdata = nd, q = q, which = "distribution", 
+     type = "distribution")

> lp <- c(predict(Colr_BH_1, newdata = nd, type = "lp"))

> nd2 <- expand.grid(q = q, lp = -lp)

> nd2$d <- c(d)

> nd2$chas <- rep(nd$chas, rep(length(q), length(lp)))

> BHtmp <- BostonHousing2

> levels(BHtmp$chas) <- levels(nd2$chas) <- levels(nd$chas) <- c("Off Charles River", 
+     "Near Charles River")

> pfun <- function(x, y, z, subscripts, at, ...) {
+     panel.contourplot(x, y, z, subscripts, at = 1:9/10, ...)
+     ch <- as.character(unique(nd2$ .... [TRUNCATED] 

> plot(contourplot(d ~ lp + q | chas, data = nd2, panel = pfun, 
+     xlab = "Linear predictor", ylab = "Median Value", col = col[1]))

> tau <- 2:18/20

> fm <- cmedv ~ crim + zn + indus + chas + nox + rm + 
+     age + dis + rad + tax + ptratio + b + lstat

> rq_BH_1 <- lapply(tau, function(p) rq(fm, data = BostonHousing2, 
+     tau = p))
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique

> Colr_BH_2 <- Colr(cmedv | crim + zn + indus + chas + 
+     nox + rm + age + dis + rad + tax + ptratio + b + lstat ~ 
+     0, data = BostonHousing2 .... [TRUNCATED] 
Warning in model.matrix.box_bases(object = list(iresponse = function (data,  :
  use scale = TRUE in as.basis.formula with sumcontr = TRUE
Warning in model.matrix.box_bases(object = list(iresponse = function (data,  :
  use scale = TRUE in as.basis.formula with sumcontr = TRUE
Warning in model.matrix.box_bases(object = list(iresponse = function (data,  :
  use scale = TRUE in as.basis.formula with sumcontr = TRUE
Warning in model.matrix.box_bases(object = list(iresponse = function (data,  :
  use scale = TRUE in as.basis.formula with sumcontr = TRUE
Warning in model.matrix.box_bases(object = list(iresponse = function (data,  :
  use scale = TRUE in as.basis.formula with sumcontr = TRUE

> idx <- order(BostonHousing2$cmedv)[ceiling(1:9/10 * 
+     NROW(BostonHousing2))]

> layout(matrix(1:9, nrow = 3))

> for (i in idx) {
+     qrq <- sapply(rq_BH_1, function(x) predict(x, newdata = BostonHousing2[i, 
+         ]))
+     nd <- BostonHousing2[i, ]
+    .... [TRUNCATED] 

> data("GBSG2", package = "TH.data")

> Survreg_GBSG2_1 <- Survreg(Surv(time, cens) ~ horTh, 
+     data = GBSG2)

> logLik(Survreg_GBSG2_1)
'log Lik.' -2632 (df=3)

> survreg_GBSG2_1 <- survreg(Surv(time, cens) ~ horTh, 
+     data = GBSG2)

> logLik(survreg_GBSG2_1)
'log Lik.' -2632 (df=3)

> c(coef(Survreg_GBSG2_1), coef(survreg_GBSG2_1)["horThyes"]/survreg_GBSG2_1$scale)
horThyes horThyes 
  0.3932   0.3932 

> exp(-rev(confint(Survreg_GBSG2_1)))
[1] 0.5284 0.8619

> nd <- data.frame(horTh = factor(c("no", "yes")))

> plot(Survreg_GBSG2_1, newdata = nd, which = "distribution", 
+     type = "survivor", confidence = "interval", fill = fill, 
+     col = col, ylab = .... [TRUNCATED] 

> legend("bottomleft", lty = 1, title = "Hormonal Therapy", 
+     legend = levels(nd$horTh), bty = "n", col = col)

> Survreg_GBSG2_2 <- Survreg(Surv(time, cens) | 0 + 
+     horTh ~ 1, data = GBSG2)

> logLik(Survreg_GBSG2_2)
'log Lik.' -2632 (df=4)

> survreg_GBSG2_2 <- survreg(Surv(time, cens) ~ strata(horTh) + 
+     horTh - 1, data = GBSG2)

> logLik(survreg_GBSG2_2)
'log Lik.' -2632 (df=4)

> coef(Survreg_GBSG2_2, with_baseline = TRUE)
           (Intercept):horThno  log(Surv(time, cens)):horThno 
                        -9.736                          1.279 
          (Intercept):horThyes log(Surv(time, cens)):horThyes 
                       -10.274                          1.299 

> c(1/survreg_GBSG2_2$scale, -coef(survreg_GBSG2_2)/survreg_GBSG2_2$scale)
      no      yes  horThno horThyes 
   1.279    1.299   -9.736  -10.274 

> Coxph_GBSG2_1 <- Coxph(Surv(time, cens) ~ horTh, data = GBSG2)

> logLik(Coxph_GBSG2_1)
'log Lik.' -2606 (df=8)

> coef(Coxph_GBSG2_1)
horThyes 
 -0.3657 

> Coxph_GBSG2_2 <- Coxph(Surv(time, cens) | 0 + horTh ~ 
+     1, data = GBSG2)

> logLik(Coxph_GBSG2_2)
'log Lik.' -2604 (df=14)

> plot(survfit(Surv(time, cens) ~ horTh, data = GBSG2), 
+     col = col, ylab = "Probability", xlab = "Survival Time")

> plot(Coxph_GBSG2_1, newdata = nd, which = "distribution", 
+     type = "survivor", col = col, add = TRUE, lty = 1)

> plot(Coxph_GBSG2_2, newdata = nd, which = "distribution", 
+     type = "survivor", col = col, add = TRUE, lty = 2)

> legend("bottomleft", lty = 1, title = "Hormonal Therapy", 
+     legend = levels(nd$horTh), bty = "n", col = col)

> data("wine", package = "ordinal")

> polr_wine <- polr(rating ~ temp + contact, data = wine)

> logLik(polr_wine)
'log Lik.' -86.49 (df=6)

> coef(polr_wine)
  tempwarm contactyes 
     2.503      1.528 

> clm_wine_1 <- clm(rating ~ temp + contact, data = wine)

> logLik(clm_wine_1)
'log Lik.' -86.49 (df=6)

> coef(clm_wine_1)
       1|2        2|3        3|4        4|5   tempwarm contactyes 
    -1.344      1.251      3.467      5.006      2.503      1.528 

> Polr_wine_1 <- Polr(rating ~ temp + contact, data = wine)

> logLik(Polr_wine_1)
'log Lik.' -86.49 (df=6)

> coef(Polr_wine_1, with_baseline = TRUE)
   rating1    rating2    rating3    rating4   tempwarm contactyes 
    -1.344      1.251      3.467      5.006      2.503      1.528 

> clm_wine_2 <- clm(rating ~ temp, nominal = ~contact, 
+     data = wine)

> logLik(clm_wine_2)
'log Lik.' -86.21 (df=9)

> coef(clm_wine_2)
1|2.(Intercept) 2|3.(Intercept) 3|4.(Intercept) 4|5.(Intercept) 
         -1.323           1.246           3.550           4.660 
 1|2.contactyes  2|3.contactyes  3|4.contactyes  4|5.contactyes 
         -1.615          -1.512          -1.675          -1.051 
       tempwarm 
          2.519 

> Polr_wine_2 <- Polr(rating | 1 + contact ~ temp, data = wine)

> logLik(Polr_wine_2)
'log Lik.' -86.21 (df=9)

> coef(Polr_wine_2, with_baseline = TRUE)
rating1:(Intercept) rating2:(Intercept) rating3:(Intercept) 
             -1.323               1.246               3.550 
rating4:(Intercept)  rating1:contactyes  rating2:contactyes 
              4.660              -1.615              -1.512 
 rating3:contactyes  rating4:contactyes            tempwarm 
             -1.675              -1.051               2.519 

> clm_wine_3 <- clm(rating ~ temp, nominal = ~contact, 
+     data = wine, link = "probit")

> logLik(clm_wine_3)
'log Lik.' -85.33 (df=9)

> coef(clm_wine_3)
1|2.(Intercept) 2|3.(Intercept) 3|4.(Intercept) 4|5.(Intercept) 
        -0.7829          0.7521          2.1323          2.7544 
 1|2.contactyes  2|3.contactyes  3|4.contactyes  4|5.contactyes 
        -0.8229         -0.8892         -1.0094         -0.5818 
       tempwarm 
         1.5114 

> Polr_wine_3 <- Polr(rating | 1 + contact ~ temp, data = wine, 
+     method = "probit")

> logLik(Polr_wine_3)
'log Lik.' -85.33 (df=9)

> coef(clm_wine_3)
1|2.(Intercept) 2|3.(Intercept) 3|4.(Intercept) 4|5.(Intercept) 
        -0.7829          0.7521          2.1323          2.7544 
 1|2.contactyes  2|3.contactyes  3|4.contactyes  4|5.contactyes 
        -0.8229         -0.8892         -1.0094         -0.5818 
       tempwarm 
         1.5114 

> erating <- wine$rating

> lrating <- erating

> rrating <- erating

> l9 <- lrating[wine$judge == 9]

> l9[l9 > 1] <- levels(l9)[unclass(l9[l9 > 1]) - 1]

> r9 <- rrating[wine$judge == 9]

> r9[r9 < 5] <- levels(r9)[unclass(r9[r9 < 5]) + 1]

> lrating[wine$judge != 9] <- rrating[wine$judge != 
+     9] <- NA

> erating[wine$judge == 9] <- NA

> lrating[wine$judge == 9] <- l9

> rrating[wine$judge == 9] <- r9

> which(wine$judge == 9)
[1] 65 66 67 68 69 70 71 72

> (wine$crating <- R(erating, cleft = lrating, cright = rrating))
 [1] (1, 2]  (2, 3]  (2, 3]  (3, 4]  (3, 4]  (3, 4]  (4, NA] (4, NA]
 [9] (NA, 1] (1, 2]  (NA, 1] (2, 3]  (1, 2]  (2, 3]  (4, NA] (3, 4] 
[17] (1, 2]  (2, 3]  (2, 3]  (1, 2]  (4, NA] (4, NA] (3, 4]  (3, 4] 
[25] (2, 3]  (1, 2]  (2, 3]  (1, 2]  (2, 3]  (1, 2]  (4, NA] (2, 3] 
[33] (1, 2]  (2, 3]  (3, 4]  (2, 3]  (2, 3]  (2, 3]  (2, 3]  (2, 3] 
[41] (2, 3]  (1, 2]  (2, 3]  (1, 2]  (1, 2]  (3, 4]  (4, NA] (3, 4] 
[49] (NA, 1] (NA, 1] (1, 2]  (1, 2]  (1, 2]  (2, 3]  (1, 2]  (2, 3] 
[57] (1, 2]  (1, 2]  (1, 2]  (2, 3]  (2, 3]  (2, 3]  (2, 3]  (3, 4] 
[65] (1, 2]  (1, 3]  (2, 4]  (1, 3]  (2, 4]  (1, 3]  (3, NA] (3, NA]

> Polr_wine_4 <- Polr(crating | contact ~ temp, data = wine, 
+     method = "probit")

> logLik(Polr_wine_4)
'log Lik.' -80.26 (df=9)

> coef(Polr_wine_4)
tempwarm 
   1.515 

> BC_BH_0 <- BoxCox(y ~ 1, data = BostonHousing2)

> logLik(BC_BH_0)
'log Lik.' -1739 (df=7)

> library("trtf")

> BC_BH_4 <- trafotree(BC_BH_0, formula = y ~ chas + 
+     crim + zn + indus + nox + rm + age + dis + rad + tax + ptratio + 
+     b + lstat, data =  .... [TRUNCATED] 

> logLik(BC_BH_4)
'log Lik.' -1249 (df=84)

> library("ATR")

> plot(rotate(BC_BH_4), terminal_panel = trtf:::node_mlt, 
+     tp_args = list(type = "density", K = 100, fill = col[1], 
+         id = FALSE))

> Coxph_GBSG2_1 <- Coxph(Surv(time, cens) ~ horTh, data = GBSG2)

> logLik(Coxph_GBSG2_1)
'log Lik.' -2606 (df=8)

> coef(Coxph_GBSG2_1)
horThyes 
 -0.3657 

> Coxph_GBSG2_3 <- trafotree(Coxph_GBSG2_1, formula = Surv(time, 
+     cens) ~ horTh | age + menostat + tsize + tgrade + pnodes + 
+     progrec + es .... [TRUNCATED] 

> logLik(Coxph_GBSG2_3)
'log Lik.' -2557 (df=24)

> coef(Coxph_GBSG2_3)[, "horThyes"]
       2        4        5 
-0.48468 -0.46049  0.09648 

> nd <- data.frame(horTh = sort(unique(GBSG2$horTh)))

> plot(Coxph_GBSG2_3, newdata = nd, tp_args = list(type = "survivor", 
+     col = col))

> GBSG2$int <- 1

> Coxph_GBSG2_3 <- Coxph(Surv(time, cens) ~ int + horTh, 
+     data = GBSG2, fixed = c(int = 0))

> (Coxph_GBSG2_4 <- trafotree(Coxph_GBSG2_3, formula = Surv(time, 
+     cens) ~ int + horTh | age + menostat + tsize + tgrade + pnodes + 
+     progr .... [TRUNCATED] 

Model formula:
Surv(time, cens) ~ int + horTh + (age + menostat + tsize + tgrade + 
    pnodes + progrec + estrec)

Fitted party:
[1] root
|   [2] pnodes <= 3: Inf (n = 376)
|   [3] pnodes > 3
|   |   [4] progrec <= 20: 624 (n = 144)
|   |   [5] progrec > 20: 1701 (n = 166)

Number of inner nodes:    2
Number of terminal nodes: 3

> logLik(Coxph_GBSG2_4)
'log Lik.' -2544 (df=24)

> coef(Coxph_GBSG2_4)[, "horThyes"]
      2       4       5 
-0.5559 -0.1104 -0.5553 

> sessionInfo()
R version 4.5.2 (2025-10-31)
Platform: x86_64-pc-linux-gnu
Running under: Debian GNU/Linux 12 (bookworm)

Matrix products: default
BLAS:   /usr/local/lib/R/lib/libRblas.so 
LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.11.0  LAPACK version 3.11.0

locale:
 [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_GB.UTF-8        LC_COLLATE=C              
 [5] LC_MONETARY=en_GB.UTF-8    LC_MESSAGES=en_GB.UTF-8   
 [7] LC_PAPER=en_GB.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C       

time zone: Europe/Berlin
tzcode source: system (glibc)

attached base packages:
[1] grid      stats     graphics  grDevices utils     datasets  methods  
[8] base     

other attached packages:
 [1] ATR_0.1-1           trtf_0.4-3          partykit_1.2-24    
 [4] libcoin_1.0-10      quantreg_6.1        SparseM_1.84-2     
 [7] colorspace_2.1-2    ordinal_2023.12-4.1 multcomp_1.4-29    
[10] TH.data_1.1-4       mlbench_2.1-6       lattice_0.22-7     
[13] MASS_7.3-65         survival_3.8-3      tram_1.3-0         
[16] mvtnorm_1.3-4       mlt_1.7-2           basefun_1.2-5      
[19] variables_1.1-2    

loaded via a namespace (and not attached):
 [1] Matrix_1.7-4         coneproj_1.21        ucminf_1.2.2        
 [4] compiler_4.5.2       rpart_4.1.24         Rcpp_1.1.0          
 [7] MatrixModels_0.5-4   orthopolynom_1.0-6.1 splines_4.5.2       
[10] alabama_2023.1.0     coda_0.19-4.1        Formula_1.2-5       
[13] knitr_1.50           iterators_1.0.14     icenReg_2.0.16      
[16] inum_1.0-5           nloptr_2.2.1         BB_2019.10-1        
[19] xfun_0.54            quadprog_1.5-8       polynom_1.4-1       
[22] foreach_1.5.2        sandwich_3.1-1       nlme_3.1-168        
[25] evaluate_1.0.5       numDeriv_2016.8-1.1  codetools_0.2-20    
[28] zoo_1.8-14           tools_4.5.2         

 *** Run successfully completed ***
> proc.time()
   user  system elapsed 
 13.067   0.249  13.412 
