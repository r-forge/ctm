
R version 3.4.3 (2017-11-30) -- "Kite-Eating Tree"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> library("mlt")
Loading required package: basefun
Loading required package: variables
> library("lattice")
> 
> data("faithful")
> 
> aic <- numeric(20)
> 
> for (o in 2:(length(aic) + 1)) {
+ Bs <- Bernstein_basis(numeric_var("waiting", support = range(faithful$waiting) + c(-5, 5)),
+                       order = o, ui = "incre")
+ m <- ctm(Bs)
+ mod <- mlt(m, data = faithful)
+ yp <- mkgrid(mod, 50)[["waiting"]]
+ 
+ aic[o - 1] <- AIC(mod)
+ 
+ pd <- data.frame(waiting = yp)
+ pd$p <- predict(mod, q = yp, type = "distribution")
+ 
+ plot(p ~ waiting, data = pd,
+      col = "red", pch = 21, main = paste("order", o, "aic", aic[o - 1]))
+ lines(ecdf(faithful$waiting))
+ 
+ }
> 
> plot(aic)
> 
> o <- which.min(aic) + 1
> Bs <- Bernstein_basis(numeric_var("waiting", support = range(faithful$waiting) + c(-5, 5)),
+                       order = o, ui = "incre")
> m <- ctm(Bs)
> mod <- mlt(m, data = faithful)
> 
> abline(h = AIC(mod))
> 
> pd$d <- predict(mod, q = yp, type = "density")
> 
> plot(d ~ waiting, data = pd, type = "l", col = "red", lwd = 3)
> lines(density(faithful$waiting))
> lines(rug(faithful$waiting))
> abline(h = 0)
> 
> p <- 1:99 / 100
> q <- predict(mod, p = p, K = 100, type = "quantile")
> 
> plot(p, q)
> lines(p, quantile(faithful$waiting, p))
> 
> Bs <- Bernstein_basis(numeric_var("waiting", support = range(faithful$waiting) + c(-5, 5)),
+                       order = o, ui = "incre")
> m <- ctm(Bs)
> mod <- mlt(m, data = faithful)
> 
> # H1 <- mod$optim(coef(mod), hessian = TRUE)$hessian
> H2 <- mod$hessian(coef(mod), weights(mod))
> 
> X <- model.matrix(m, faithful)
> Xprime <- model.matrix(m, faithful, deriv = c(waiting = 1))
> w <- drop((Xprime %*% coef(mod))^2)
> H3 <- crossprod(X) + crossprod(Xprime * w, Xprime)
> max(abs(H3 - H2))
[1] 9.885613
> 
> cov2cor(vcov(mod))
             Bs1(waiting) Bs2(waiting) Bs3(waiting) Bs4(waiting) Bs5(waiting)
Bs1(waiting)    1.0000000   -0.9652657    0.9032055   -0.8310319    0.7513998
Bs2(waiting)   -0.9652657    1.0000000   -0.9793104    0.9309906   -0.8628109
Bs3(waiting)    0.9032055   -0.9793104    1.0000000   -0.9835441    0.9383220
Bs4(waiting)   -0.8310319    0.9309906   -0.9835441    1.0000000   -0.9837278
Bs5(waiting)    0.7513998   -0.8628109    0.9383220   -0.9837278    1.0000000
Bs6(waiting)   -0.6649921    0.7788036   -0.8677583    0.9357830   -0.9824465
Bs7(waiting)    0.5741526   -0.6830282    0.7767012   -0.8583345    0.9286164
Bs8(waiting)   -0.4756214    0.5730200   -0.6625701    0.7479345   -0.8313485
Bs9(waiting)    0.3573298   -0.4341441    0.5079555   -0.5821471    0.6606659
             Bs6(waiting) Bs7(waiting) Bs8(waiting) Bs9(waiting)
Bs1(waiting)   -0.6649921    0.5741526   -0.4756214    0.3573298
Bs2(waiting)    0.7788036   -0.6830282    0.5730200   -0.4341441
Bs3(waiting)   -0.8677583    0.7767012   -0.6625701    0.5079555
Bs4(waiting)    0.9357830   -0.8583345    0.7479345   -0.5821471
Bs5(waiting)   -0.9824465    0.9286164   -0.8313485    0.6606659
Bs6(waiting)    1.0000000   -0.9794871    0.9079640   -0.7427123
Bs7(waiting)   -0.9794871    1.0000000   -0.9699965    0.8292219
Bs8(waiting)    0.9079640   -0.9699965    1.0000000   -0.9214163
Bs9(waiting)   -0.7427123    0.8292219   -0.9214163    1.0000000
> 
> if (FALSE) {
+ library("multcomp") ### since 1.0-3
+ 
+ mp <- parm(coef(mod), vcov(mod))
+ y <- mkgrid(mod, 30)$waiting
+ g <- glht(mp, linfct = model.matrix(mod$model,
+     data = data.frame(waiting = y)))
+ 
+ mc <- confint(g)
+ umc <- confint(g, calpha = qnorm(.975))
+ p <- mod$model$todistr$p
+ plot(y, p(mc$confint[, "Estimate"]), type = "l")
+ lines(y, p(mc$confint[, "lwr"]))
+ lines(y, p(mc$confint[, "upr"]))
+ lines(y, p(umc$confint[, "lwr"]))
+ lines(y, p(umc$confint[, "upr"]))
+ 
+ library("survival")
+ cm <- coxph(Surv(waiting, rep(TRUE, nrow(faithful))) ~ 1, data = faithful)
+ plot(survfit(cm))
+ lines(y, 1 - p(mc$confint[, "Estimate"]), col = "red")
+ lines(y, 1 - p(mc$confint[, "lwr"]), col = "red")
+ lines(y, 1 - p(mc$confint[, "upr"]), col = "red")
+ }
> 
> proc.time()
   user  system elapsed 
  4.444   0.080   4.523 
