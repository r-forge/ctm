
R version 4.1.1 (2021-08-10) -- "Kick Things"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### test for mcotram
> library("cotram")
Loading required package: tram
Loading required package: mlt
Loading required package: basefun
Loading required package: variables

Attaching package: 'cotram'

The following object is masked from 'package:mlt':

    confband

> library("mvtnorm")
> options(digits = 2)
> ########################################################
> ################ constant Lambda - data ################
> ########################################################
> set.seed(123)
> N <- 1000
> J <- 2 ## define dimension
> 
> Lambda <- diag(J)
> Lambda[lower.tri(Lambda)] <- (value <- 0.9)  ## choose 0 for uncorrelated responses
> Sigma <- tcrossprod(solve(Lambda))
> 
> p <- 2
> x <- matrix(runif(N * p), ncol = p)
> 
> beta <- c(1, -1, -.5, .5) ## depends on dimension J and number of predictors p
> 
> ly <- x %*% matrix(beta, nrow = p) + rmvnorm(N, sigma = Sigma)
> ly_marg <- pnorm(ly)
> y <- qbinom(ly_marg, size = 10, prob = 0.3) 
> 
> ## or take different distributions for the two margins
> # y <- ly
> # y[,1] <- qbinom(ly_marg[,1], size = 15, prob = 0.2) 
> # y[,2] <- qbinom(ly_marg[,2], size = 10, prob = 0.3) 
> 
> d <- data.frame(y = y, x = x)
> 
> ##################################################
> ###### constant lambda, marginal models ~ 1 ######
> ##################################################
> ## here we don't expect a great performance as the marginal models are
> ## very simple
> 
> ## marginal cotram models with log_first = TRUE (default)
> u1 <- cotram(y.1 ~ 1, data = d, method = "probit")
> u2 <- cotram(y.2 ~ 1, data = d, method = "probit")
> 
> ## joint models with different orders of the marginals, constant lambdas
> uc1 <- mcotram(u1, u2, data = d)
> uc2 <- mcotram(u2, u1, data = d)
> ## these log-likelihoods are expected to be very close, but not equal
> logLik(uc1)
'log Lik.' -3571 (df=15)
> logLik(uc2)
'log Lik.' -3575 (df=15)
> 
> ## check gradient
> all.equal(uc1$sc(uc2$par), numDeriv::grad(uc1$ll, uc2$par),
+           tol = 1e-6, check.attributes = FALSE)
[1] TRUE
> 
> ## marginal cotram models with log_first = FALSE
> u1l <- cotram(y.1 ~ 1, data = d, method = "probit", log_first = FALSE)
> u2l <- cotram(y.2 ~ 1, data = d, method = "probit", log_first = FALSE)
> uc1l <- mcotram(u1l, u2l, data = d)
> uc2l <- mcotram(u2l, u1l, data = d)
> logLik(uc1l)
'log Lik.' -3569 (df=15)
> logLik(uc2l)
'log Lik.' -3572 (df=15)
> all.equal(uc1l$sc(uc2l$par), numDeriv::grad(uc1l$ll, uc2l$par),
+           tol = 1e-6, check.attributes = FALSE)
[1] TRUE
> 
> ## compare coefficients
> ## log_first = TRUE
> # coef(uc1)
> # coef(uc2)
> value ## recall original value for Lambda
[1] 0.9
> coef(uc1, type = "Lambda")[1,] 
   1 
0.94 
> coef(uc2, type = "Lambda")[1,]
   1 
0.99 
> cov2cor(Sigma)[1, 2] ## original value for correlation
[1] -0.67
> coef(uc1, type = "Corr")[1,]
[1] -0.69
> coef(uc2, type = "Corr")[1,]
[1] -0.7
> 
> ## log_first = FALSE
> # coef(uc1l)
> # coef(uc2l)
> coef(uc1l, type = "Lambda")[1,]
   1 
0.94 
> coef(uc2l, type = "Lambda")[1,]
   1 
0.99 
> 
> coef(uc1l, type = "Corr")[1,]
[1] -0.69
> coef(uc2l, type = "Corr")[1,]
[1] -0.7
> 
> ## transformation theory check
> ## for constant lambdas, the transformed coefficients should agree with the
> ## coefficients of the model with the different order
> 
> ## here, the results are not great because the marginal models are too simple
> 
> ## log_first = TRUE
> coef(uc1)[-c(1:7, 15)] / sqrt(coef(uc1, type = "Sigma")$diagonal[1,2])
y.2.Bs1(y.2) y.2.Bs2(y.2) y.2.Bs3(y.2) y.2.Bs4(y.2) y.2.Bs5(y.2) y.2.Bs6(y.2) 
       -1.67        -1.67        -1.53        -0.62        -0.62         0.23 
y.2.Bs7(y.2) 
        1.66 
> coef(uc2)[1:7]
y.2.Bs1(y.2) y.2.Bs2(y.2) y.2.Bs3(y.2) y.2.Bs4(y.2) y.2.Bs5(y.2) y.2.Bs6(y.2) 
       -1.97        -1.58        -1.58        -0.57        -0.57         0.20 
y.2.Bs7(y.2) 
        1.69 
> 
> coef(uc2)[-c(1:7, 15)] / sqrt(coef(uc2, type = "Sigma")$diagonal[1,2])
y.1.Bs1(y.1) y.1.Bs2(y.1) y.1.Bs3(y.1) y.1.Bs4(y.1) y.1.Bs5(y.1) y.1.Bs6(y.1) 
      -3.007       -1.682       -1.673       -1.673       -0.328        0.013 
y.1.Bs7(y.1) 
       1.465 
> coef(uc1)[1:7]
y.1.Bs1(y.1) y.1.Bs2(y.1) y.1.Bs3(y.1) y.1.Bs4(y.1) y.1.Bs5(y.1) y.1.Bs6(y.1) 
      -2.140       -2.140       -1.782       -1.527       -0.311       -0.023 
y.1.Bs7(y.1) 
       1.560 
> 
> ## log_first = FALSE?
> coef(uc1l)[-c(1:7, 15)] / sqrt(coef(uc1l, type = "Sigma")$diagonal[1,2])
y.2.Bs1(y.2) y.2.Bs2(y.2) y.2.Bs3(y.2) y.2.Bs4(y.2) y.2.Bs5(y.2) y.2.Bs6(y.2) 
      -1.819       -0.925       -0.174       -0.082        0.656        1.205 
y.2.Bs7(y.2) 
       1.655 
> coef(uc2l)[1:7]
y.2.Bs1(y.2) y.2.Bs2(y.2) y.2.Bs3(y.2) y.2.Bs4(y.2) y.2.Bs5(y.2) y.2.Bs6(y.2) 
       -1.95        -0.71        -0.38         0.15         0.54         1.23 
y.2.Bs7(y.2) 
        1.69 
> 
> coef(uc2l)[-c(1:7, 15)] / sqrt(coef(uc2l, type = "Sigma")$diagonal[1,2])
y.1.Bs1(y.1) y.1.Bs2(y.1) y.1.Bs3(y.1) y.1.Bs4(y.1) y.1.Bs5(y.1) y.1.Bs6(y.1) 
       -2.19        -1.54        -0.34        -0.34         0.66         0.90 
y.1.Bs7(y.1) 
        1.43 
> coef(uc1l)[1:7]
y.1.Bs1(y.1) y.1.Bs2(y.1) y.1.Bs3(y.1) y.1.Bs4(y.1) y.1.Bs5(y.1) y.1.Bs6(y.1) 
       -2.27        -1.52        -0.31        -0.31         0.66         0.95 
y.1.Bs7(y.1) 
        1.53 
> 
> ### predict accuracy
> cbind(u1 = predict(u1, newdata = d[1:3, ], type = "distribution"),
+       uc1 = predict(uc1, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       uc2 = predict(uc2, marginal = 2, newdata = d[1:3, ], type = "distribution"))
     u1            
1 0.401 0.407 0.398
2 0.646 0.646 0.635
3 0.037 0.034 0.037
> cbind(u2 = predict(u2, newdata = d[1:3, ], type = "distribution"),
+       uc1 = predict(uc1, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       uc2 = predict(uc2, marginal = 1, newdata = d[1:3, ], type = "distribution"))
    u2          
1 0.40 0.40 0.41
2 0.60 0.59 0.60
3 0.96 0.95 0.95
> ## log_first = TRUE seems to perform slightly better
> 
> cbind(u1l = predict(u1l, newdata = d[1:3, ], type = "distribution"),
+       uc1l = predict(uc1l, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       uc2l = predict(uc2l, marginal = 2, newdata = d[1:3, ], type = "distribution"))
    u1l            
1 0.398 0.404 0.396
2 0.650 0.648 0.637
3 0.037 0.034 0.037
> cbind(u2l = predict(u2l, newdata = d[1:3, ], type = "distribution"),
+       uc1l = predict(uc1l, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       uc2l = predict(uc2l, marginal = 1, newdata = d[1:3, ], type = "distribution"))
   u2l          
1 0.40 0.41 0.41
2 0.59 0.59 0.60
3 0.95 0.95 0.95
> 
> ## QQ-plot to check that marginal transformations are standard normal:
> ## plots don't look great since the marginal models are too simple
> nd <- d
> par(mfrow = c(2, 2))
> d1 <- predict(uc1, marginal = 1, newdata = d, type = "trafo")
> qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
> qqline(d1, col = "red")
> 
> d2 <- predict(uc1, marginal = 2, newdata = d, type = "trafo")
> qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
> qqline(d2, col = "red")
> 
> d3 <- predict(uc2, marginal = 2, newdata = d, type = "trafo")
> qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
> qqline(d3, col = "red")
> 
> d4 <- predict(uc2, marginal = 1, newdata = d, type = "trafo")
> qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
> qqline(d4, col = "red")
> 
> ## log_first = FALSE
> d1 <- predict(uc1l, marginal = 1, newdata = d, type = "trafo")
> qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
> qqline(d1, col = "red")
> 
> d2 <- predict(uc1l, marginal = 2, newdata = d, type = "trafo")
> qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
> qqline(d2, col = "red")
> 
> d3 <- predict(uc2l, marginal = 2, newdata = d, type = "trafo")
> qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
> qqline(d3, col = "red")
> 
> d4 <- predict(uc2l, marginal = 1, newdata = d, type = "trafo")
> qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
> qqline(d4, col = "red")
> 
> #### continuous approximation
> ## data - 0.5 (and + 1 depending on log_first)
> yt <- y - 0.5*(y > 0)
> ytt <- yt + 1
> ytu <- y - runif(length(y))*(y > 0)
> ytut <- ytu + 1
> d <- data.frame(y = y, yt = yt, ytt = ytt, ytu = ytu, ytut = ytut, x = x)
> 
> ## univariate BoxCox models, log_first = TRUE
> ## need plus_one = TRUE: achieve this by yt + 1 or ytu + 1
> b1 <- BoxCox(ytt.1 ~ 1, data = d, log_first = TRUE)
> b2 <- BoxCox(ytt.2 ~ 1, data = d, log_first = TRUE)
> b1u <- BoxCox(ytut.1 ~ 1, data = d, log_first = TRUE)
> b2u <- BoxCox(ytut.2 ~ 1, data = d, log_first = TRUE)
> logLik(b1)
'log Lik.' -1738 (df=7)
> logLik(b1u)
'log Lik.' -1808 (df=7)
> logLik(b2)
'log Lik.' -1903 (df=7)
> logLik(b2u)
'log Lik.' -1927 (df=7)
> 
> ## log_first = FALSE. Here it doesn't matter if we take y+1 or just y
> b1l <- BoxCox(yt.1 ~ 1, data = d, log_first = FALSE)
> b2l <- BoxCox(yt.2 ~ 1, data = d, log_first = FALSE)
> b1ul <- BoxCox(ytu.1 ~ 1, data = d, log_first = FALSE)
> b2ul <- BoxCox(ytu.2 ~ 1, data = d, log_first = FALSE)
> logLik(b1l)
'log Lik.' -1773 (df=7)
> logLik(b1ul)
'log Lik.' -1822 (df=7)
> logLik(b2l)
'log Lik.' -1953 (df=7)
> logLik(b2ul)
'log Lik.' -1962 (df=7)
> 
> ## multivariate mmlt models
> mb1 <- mmlt(b1, b2, data = d)
> mb2 <- mmlt(b2, b1, data = d)
> logLik(mb1)
'log Lik.' -3346 (df=15)
> logLik(mb2)
'log Lik.' -3346 (df=15)
> mb1u <- mmlt(b1u, b2u, data = d)
> mb2u <- mmlt(b2u, b1u, data = d)
> logLik(mb1u)
'log Lik.' -3457 (df=15)
> logLik(mb2u)
'log Lik.' -3457 (df=15)
> 
> mb1l <- mmlt(b1l, b2l, data = d)
> mb2l <- mmlt(b2l, b1l, data = d)
> logLik(mb1l)
'log Lik.' -3432 (df=15)
> logLik(mb2l)
'log Lik.' -3432 (df=15)
> mb1ul <- mmlt(b1ul, b2ul, data = d)
> mb2ul <- mmlt(b2ul, b1ul, data = d)
> logLik(mb1ul)
'log Lik.' -3509 (df=15)
> logLik(mb2ul)
'log Lik.' -3509 (df=15)
> ## compare coef
> # coef(mb1)
> # coef(mb2)
> coef(mb1, type = "Lambda")[1,]
  1 
0.9 
> coef(mb2, type = "Lambda")[1,]
  1 
0.9 
> coef(mb1, type = "Corr")[1,]
[1] -0.67
> coef(mb2, type = "Corr")[1,]
[1] -0.67
> 
> coef(mb1u, type = "Lambda")[1,]
   1 
0.86 
> coef(mb2u, type = "Lambda")[1,]
   1 
0.86 
> coef(mb1u, type = "Corr")[1,]
[1] -0.65
> coef(mb2u, type = "Corr")[1,]
[1] -0.65
> 
> ## log_first = FALSE
> # coef(mb1l)
> # coef(mb2l)
> coef(mb1l, type = "Lambda")[1,]
   1 
0.89 
> coef(mb2l, type = "Lambda")[1,]
  1 
0.9 
> coef(mb1l, type = "Corr")[1,]
[1] -0.67
> coef(mb2l, type = "Corr")[1,]
[1] -0.67
> 
> coef(mb1ul, type = "Lambda")[1,]
   1 
0.86 
> coef(mb2ul, type = "Lambda")[1,]
   1 
0.86 
> coef(mb1ul, type = "Corr")[1,]
[1] -0.65
> coef(mb2ul, type = "Corr")[1,]
[1] -0.65
> 
> ## transformation theory check
> ## for constant lambdas, the transformed coefficients should agree with the
> ## coefficients of the model with the different order
> 
> ## log_first = TRUE
> coef(mb1)[-c(1:7, 15)] / sqrt(coef(mb1, type = "Sigma")$diagonal[1,2])
yt.2.Bs1(ytt.2) yt.2.Bs2(ytt.2) yt.2.Bs3(ytt.2) yt.2.Bs4(ytt.2) yt.2.Bs5(ytt.2) 
          -1.08           -0.60           -0.60           -0.59            0.55 
yt.2.Bs6(ytt.2) yt.2.Bs7(ytt.2) 
           0.55            1.43 
> coef(mb2)[1:7]
yt.2.Bs1(ytt.2) yt.2.Bs2(ytt.2) yt.2.Bs3(ytt.2) yt.2.Bs4(ytt.2) yt.2.Bs5(ytt.2) 
          -1.08           -0.60           -0.60           -0.59            0.55 
yt.2.Bs6(ytt.2) yt.2.Bs7(ytt.2) 
           0.55            1.43 
> 
> coef(mb2)[-c(1:7, 15)] / sqrt(coef(mb2, type = "Sigma")$diagonal[1,2])
yt.1.Bs1(ytt.1) yt.1.Bs2(ytt.1) yt.1.Bs3(ytt.1) yt.1.Bs4(ytt.1) yt.1.Bs5(ytt.1) 
          -1.32           -0.83           -0.83           -0.79            0.46 
yt.1.Bs6(ytt.1) yt.1.Bs7(ytt.1) 
           0.46            1.24 
> coef(mb1)[1:7]
yt.1.Bs1(ytt.1) yt.1.Bs2(ytt.1) yt.1.Bs3(ytt.1) yt.1.Bs4(ytt.1) yt.1.Bs5(ytt.1) 
          -1.32           -0.83           -0.83           -0.79            0.46 
yt.1.Bs6(ytt.1) yt.1.Bs7(ytt.1) 
           0.46            1.24 
> 
> coef(mb1u)[-c(1:7, 15)] / sqrt(coef(mb1u, type = "Sigma")$diagonal[1,2])
yt.2.Bs1(ytut.2) yt.2.Bs2(ytut.2) yt.2.Bs3(ytut.2) yt.2.Bs4(ytut.2) 
           -1.53            -0.81            -0.81            -0.70 
yt.2.Bs5(ytut.2) yt.2.Bs6(ytut.2) yt.2.Bs7(ytut.2) 
            0.11             0.37             1.31 
> coef(mb2u)[1:7]
yt.2.Bs1(ytut.2) yt.2.Bs2(ytut.2) yt.2.Bs3(ytut.2) yt.2.Bs4(ytut.2) 
           -1.53            -0.81            -0.81            -0.70 
yt.2.Bs5(ytut.2) yt.2.Bs6(ytut.2) yt.2.Bs7(ytut.2) 
            0.11             0.37             1.31 
> 
> coef(mb2u)[-c(1:7, 15)] / sqrt(coef(mb2u, type = "Sigma")$diagonal[1,2])
yt.1.Bs1(ytut.1) yt.1.Bs2(ytut.1) yt.1.Bs3(ytut.1) yt.1.Bs4(ytut.1) 
          -1.335           -0.963           -0.963           -0.087 
yt.1.Bs5(ytut.1) yt.1.Bs6(ytut.1) yt.1.Bs7(ytut.1) 
          -0.087            0.593            1.337 
> coef(mb1u)[1:7]
yt.1.Bs1(ytut.1) yt.1.Bs2(ytut.1) yt.1.Bs3(ytut.1) yt.1.Bs4(ytut.1) 
          -1.335           -0.963           -0.963           -0.086 
yt.1.Bs5(ytut.1) yt.1.Bs6(ytut.1) yt.1.Bs7(ytut.1) 
          -0.086            0.593            1.337 
> 
> ## log_first = FALSE
> ## results not great but probably because the marginal models are too simple
> coef(mb1l)[-c(1:7, 15)] / sqrt(coef(mb1l, type = "Sigma")$diagonal[1,2])
yt.2.Bs1(yt.2) yt.2.Bs2(yt.2) yt.2.Bs3(yt.2) yt.2.Bs4(yt.2) yt.2.Bs5(yt.2) 
        -1.199         -0.213         -0.213         -0.064          0.988 
yt.2.Bs6(yt.2) yt.2.Bs7(yt.2) 
         0.988          1.398 
> coef(mb2l)[1:7]
yt.2.Bs1(yt.2) yt.2.Bs2(yt.2) yt.2.Bs3(yt.2) yt.2.Bs4(yt.2) yt.2.Bs5(yt.2) 
        -1.199         -0.213         -0.213         -0.065          0.988 
yt.2.Bs6(yt.2) yt.2.Bs7(yt.2) 
         0.988          1.398 
> 
> coef(mb2l)[-c(1:7, 15)] / sqrt(coef(mb2l, type = "Sigma")$diagonal[1,2])
yt.1.Bs1(yt.1) yt.1.Bs2(yt.1) yt.1.Bs3(yt.1) yt.1.Bs4(yt.1) yt.1.Bs5(yt.1) 
        -1.422         -0.528         -0.528         -0.028          0.779 
yt.1.Bs6(yt.1) yt.1.Bs7(yt.1) 
         0.779          1.194 
> coef(mb1l)[1:7]
yt.1.Bs1(yt.1) yt.1.Bs2(yt.1) yt.1.Bs3(yt.1) yt.1.Bs4(yt.1) yt.1.Bs5(yt.1) 
        -1.423         -0.528         -0.528         -0.028          0.780 
yt.1.Bs6(yt.1) yt.1.Bs7(yt.1) 
         0.780          1.194 
> 
> coef(mb1ul)[-c(1:7, 15)] / sqrt(coef(mb1ul, type = "Sigma")$diagonal[1,2])
yt.2.Bs1(ytu.2) yt.2.Bs2(ytu.2) yt.2.Bs3(ytu.2) yt.2.Bs4(ytu.2) yt.2.Bs5(ytu.2) 
          -1.59           -0.35           -0.35           -0.17            0.70 
yt.2.Bs6(ytu.2) yt.2.Bs7(ytu.2) 
           0.88            1.29 
> coef(mb2ul)[1:7]
yt.2.Bs1(ytu.2) yt.2.Bs2(ytu.2) yt.2.Bs3(ytu.2) yt.2.Bs4(ytu.2) yt.2.Bs5(ytu.2) 
          -1.59           -0.35           -0.35           -0.17            0.70 
yt.2.Bs6(ytu.2) yt.2.Bs7(ytu.2) 
           0.88            1.29 
> 
> coef(mb2ul)[-c(1:7, 15)] / sqrt(coef(mb2ul, type = "Sigma")$diagonal[1,2])
yt.1.Bs1(ytu.1) yt.1.Bs2(ytu.1) yt.1.Bs3(ytu.1) yt.1.Bs4(ytu.1) yt.1.Bs5(ytu.1) 
          -1.39           -0.58           -0.49            0.23            0.46 
yt.1.Bs6(ytu.1) yt.1.Bs7(ytu.1) 
           0.94            1.32 
> coef(mb1ul)[1:7]
yt.1.Bs1(ytu.1) yt.1.Bs2(ytu.1) yt.1.Bs3(ytu.1) yt.1.Bs4(ytu.1) yt.1.Bs5(ytu.1) 
          -1.39           -0.58           -0.49            0.23            0.46 
yt.1.Bs6(ytu.1) yt.1.Bs7(ytu.1) 
           0.94            1.32 
> 
> ### predict accuracy
> cbind(b1 = predict(b1, newdata = d[1:3, ], type = "distribution"),
+       mb1 = predict(mb1, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       mb2 = predict(mb2, marginal = 2, newdata = d[1:3, ], type = "distribution"))
     b1            
1 0.263 0.267 0.267
2 0.529 0.531 0.531
3 0.014 0.013 0.013
> cbind(b2 = predict(b2, newdata = d[1:3, ], type = "distribution"),
+       mb1 = predict(mb1, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       mb2 = predict(mb2, marginal = 1, newdata = d[1:3, ], type = "distribution"))
    b2          
1 0.31 0.31 0.31
2 0.50 0.50 0.50
3 0.92 0.92 0.92
> 
> cbind(b1u = predict(b1u, newdata = d[1:3, ], type = "distribution"),
+       mb1u = predict(mb1u, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       mb2u = predict(mb2u, marginal = 2, newdata = d[1:3, ], type = "distribution"))
    b1u            
1 0.304 0.305 0.305
2 0.578 0.578 0.578
3 0.022 0.023 0.023
> cbind(b2u = predict(b2u, newdata = d[1:3, ], type = "distribution"),
+       mb1u = predict(mb1u, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       mb2u = predict(mb2u, marginal = 1, newdata = d[1:3, ], type = "distribution"))
   b2u          
1 0.40 0.40 0.40
2 0.50 0.50 0.50
3 0.91 0.91 0.91
> 
> cbind(b1l = predict(b1l, newdata = d[1:3, ], type = "distribution"),
+       mb1l = predict(mb1l, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       mb2l = predict(mb2l, marginal = 2, newdata = d[1:3, ], type = "distribution"))
    b1l            
1 0.280 0.284 0.284
2 0.527 0.528 0.528
3 0.019 0.018 0.018
> cbind(b2l = predict(b2l, newdata = d[1:3, ], type = "distribution"),
+       mb1l = predict(mb1l, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       mb2l = predict(mb2l, marginal = 1, newdata = d[1:3, ], type = "distribution"))
   b2l          
1 0.33 0.33 0.33
2 0.50 0.50 0.50
3 0.92 0.92 0.92
> 
> cbind(b1ul = predict(b1ul, newdata = d[1:3, ], type = "distribution"),
+       mb1ul = predict(mb1ul, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       mb2ul = predict(mb2ul, marginal = 2, newdata = d[1:3, ], type = "distribution"))
   b1ul            
1 0.305 0.306 0.306
2 0.580 0.579 0.579
3 0.025 0.025 0.025
> cbind(b2ul = predict(b2ul, newdata = d[1:3, ], type = "distribution"),
+       mb1ul = predict(mb1ul, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       mb2ul = predict(mb2ul, marginal = 1, newdata = d[1:3, ], type = "distribution"))
  b2ul          
1 0.40 0.41 0.41
2 0.49 0.50 0.50
3 0.90 0.90 0.90
> 
> ## QQ-plot to check that marginal transformations are standard normal:
> nd <- d
> par(mfrow = c(2, 2))
> d1 <- predict(mb1, marginal = 1, newdata = d, type = "trafo")
> qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
> qqline(d1, col = "red")
> 
> d2 <- predict(mb1, marginal = 2, newdata = d, type = "trafo")
> qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
> qqline(d2, col = "red")
> 
> d3 <- predict(mb2, marginal = 2, newdata = d, type = "trafo")
> qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
> qqline(d3, col = "red")
> 
> d4 <- predict(mb2, marginal = 1, newdata = d, type = "trafo")
> qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
> qqline(d4, col = "red")
> 
> 
> d1 <- predict(mb1u, marginal = 1, newdata = d, type = "trafo")
> qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
> qqline(d1, col = "red")
> 
> d2 <- predict(mb1u, marginal = 2, newdata = d, type = "trafo")
> qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
> qqline(d2, col = "red")
> 
> d3 <- predict(mb2u, marginal = 2, newdata = d, type = "trafo")
> qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
> qqline(d3, col = "red")
> 
> d4 <- predict(mb2u, marginal = 1, newdata = d, type = "trafo")
> qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
> qqline(d4, col = "red")
> 
> ## log_first = FALSE
> d1 <- predict(mb1l, marginal = 1, newdata = d, type = "trafo")
> qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
> qqline(d1, col = "red")
> 
> d2 <- predict(mb1l, marginal = 2, newdata = d, type = "trafo")
> qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
> qqline(d2, col = "red")
> 
> d3 <- predict(mb2l, marginal = 2, newdata = d, type = "trafo")
> qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
> qqline(d3, col = "red")
> 
> d4 <- predict(mb2l, marginal = 1, newdata = d, type = "trafo")
> qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
> qqline(d4, col = "red")
> 
> 
> d1 <- predict(mb1ul, marginal = 1, newdata = d, type = "trafo")
> qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
> qqline(d1, col = "red")
> 
> d2 <- predict(mb1ul, marginal = 2, newdata = d, type = "trafo")
> qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
> qqline(d2, col = "red")
> 
> d3 <- predict(mb2ul, marginal = 2, newdata = d, type = "trafo")
> qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
> qqline(d3, col = "red")
> 
> d4 <- predict(mb2ul, marginal = 1, newdata = d, type = "trafo")
> qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
> qqline(d4, col = "red")
> 
> ### make CRAN team happy
> if (FALSE) {
+ 
+ ##########################################################
+ ###### constant lambda, marginal models ~ x.1 + x.2 ######
+ ##########################################################
+ ## cotram models for the marginals
+ u1 <- cotram(y.1 ~ x.1 + x.2, data = d, method = "probit")
+ u2 <- cotram(y.2 ~ x.1 + x.2, data = d, method = "probit")
+ 
+ ## joint models with different orders of the marginals, constant lambdas
+ uc1 <- mcotram(u1, u2, data = d)
+ uc2 <- mcotram(u2, u1, data = d)
+ logLik(uc1)
+ logLik(uc2) ## these log-likelihoods are expected to be very close, but not equal
+ 
+ ## check gradient
+ all.equal(uc1$sc(uc2$par), numDeriv::grad(uc1$ll, uc2$par),
+           tol = 1e-6, check.attributes = FALSE)
+ 
+ ## marginal cotram models with log_first = FALSE
+ # uc1 <- uc2 <- 0
+ u1l <- cotram(y.1 ~ x.1 + x.2, data = d, method = "probit", log_first = FALSE)
+ u2l <- cotram(y.2 ~ x.1 + x.2, data = d, method = "probit", log_first = FALSE)
+ uc1l <- mcotram(u1l, u2l, data = d)
+ uc2l <- mcotram(u2l, u1l, data = d)
+ logLik(uc1l)
+ logLik(uc2l)
+ all.equal(uc1l$sc(uc2l$par), numDeriv::grad(uc1l$ll, uc2l$par),
+           tol = 1e-6, check.attributes = FALSE)
+ 
+ ## compare coefficients
+ ## recall beta:
+ beta
+ ## log_first = TRUE
+ coef(uc1)
+ coef(uc2)
+ value
+ coef(uc1, type = "Lambda")[1,] 
+ coef(uc2, type = "Lambda")[1,]
+ cov2cor(Sigma)[1, 2]
+ coef(uc1, type = "Corr")[1,]
+ coef(uc2, type = "Corr")[1,]
+ 
+ ## log_first = FALSE
+ beta
+ coef(uc1l)
+ coef(uc2l)
+ coef(uc1l, type = "Lambda")[1,]
+ coef(uc2l, type = "Lambda")[1,]
+ coef(uc1l, type = "Corr")[1,]
+ coef(uc2l, type = "Corr")[1,]
+ 
+ ## transformation theory check
+ ## for constant lambdas, the transformed coefficients should agree with the
+ ## coefficients of the model with the different order
+ 
+ ## log_first = TRUE
+ ## seems to agree better than log_first = FALSE
+ coef(uc1)[-c(1:9, 19)] / sqrt(coef(uc1, type = "Sigma")$diagonal[1,2])
+ coef(uc2)[1:9]
+ 
+ coef(uc2)[-c(1:9, 19)] / sqrt(coef(uc2, type = "Sigma")$diagonal[1,2])
+ coef(uc1)[1:9]
+ 
+ ## log_first = FALSE
+ coef(uc1l)[-c(1:9, 19)] / sqrt(coef(uc1l, type = "Sigma")$diagonal[1,2])
+ coef(uc2l)[1:9]
+ 
+ coef(uc2l)[-c(1:9, 19)] / sqrt(coef(uc2l, type = "Sigma")$diagonal[1,2])
+ coef(uc1l)[1:9]
+ 
+ ### predict accuracy
+ cbind(u1 = predict(u1, newdata = d[1:3, ], type = "distribution"),
+       uc1 = predict(uc1, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       uc2 = predict(uc2, marginal = 2, newdata = d[1:3, ], type = "distribution"))
+ cbind(u2 = predict(u2, newdata = d[1:3, ], type = "distribution"),
+       uc1 = predict(uc1, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       uc2 = predict(uc2, marginal = 1, newdata = d[1:3, ], type = "distribution"))
+ 
+ cbind(u1l = predict(u1l, newdata = d[1:3, ], type = "distribution"),
+       uc1l = predict(uc1l, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       uc2l = predict(uc2l, marginal = 2, newdata = d[1:3, ], type = "distribution"))
+ cbind(u2l = predict(u2l, newdata = d[1:3, ], type = "distribution"),
+       uc1l = predict(uc1l, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       uc2l = predict(uc2l, marginal = 1, newdata = d[1:3, ], type = "distribution"))
+ 
+ ## QQ-plot to check that marginal transformations are standard normal:
+ nd <- d
+ par(mfrow = c(2, 2))
+ d1 <- predict(uc1, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
+ qqline(d1, col = "red")
+ 
+ d2 <- predict(uc1, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
+ qqline(d2, col = "red")
+ 
+ d3 <- predict(uc2, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
+ qqline(d3, col = "red")
+ 
+ d4 <- predict(uc2, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
+ qqline(d4, col = "red")
+ 
+ ## log_first = FALSE
+ d1 <- predict(uc1l, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
+ qqline(d1, col = "red")
+ 
+ d2 <- predict(uc1l, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
+ qqline(d2, col = "red")
+ 
+ d3 <- predict(uc2l, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
+ qqline(d3, col = "red")
+ 
+ d4 <- predict(uc2l, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
+ qqline(d4, col = "red")
+ 
+ #### continuous approximation
+ ## univariate BoxCox models, log_first = TRUE
+ b1 <- BoxCox(ytt.1 ~ x.1 + x.2, data = d, log_first = TRUE)
+ b2 <- BoxCox(ytt.2 ~ x.1 + x.2, data = d, log_first = TRUE)
+ b1u <- BoxCox(ytut.1 ~ x.1 + x.2, data = d, log_first = TRUE)
+ b2u <- BoxCox(ytut.2 ~ x.1 + x.2, data = d, log_first = TRUE)
+ logLik(b1)
+ logLik(b1u)
+ logLik(b2)
+ logLik(b2u)
+ 
+ b1l <- BoxCox(yt.1 ~ x.1 + x.2, data = d, log_first = FALSE)
+ b2l <- BoxCox(yt.2 ~ x.1 + x.2, data = d, log_first = FALSE)
+ b1ul <- BoxCox(ytu.1 ~ x.1 + x.2, data = d, log_first = FALSE)
+ b2ul <- BoxCox(ytu.2 ~ x.1 + x.2, data = d, log_first = FALSE)
+ logLik(b1l)
+ logLik(b1ul)
+ logLik(b2l)
+ logLik(b2ul)
+ ## multivariate mmlt models
+ mb1 <- mmlt(b1, b2, data = d)
+ mb2 <- mmlt(b2, b1, data = d)
+ logLik(mb1)
+ logLik(mb2)
+ 
+ mb1u <- mmlt(b1u, b2u, data = d)
+ mb2u <- mmlt(b2u, b1u, data = d)
+ logLik(mb1u)
+ logLik(mb2u)
+ 
+ mb1l <- mmlt(b1l, b2l, data = d)
+ mb2l <- mmlt(b2l, b1l, data = d)
+ logLik(mb1l)
+ logLik(mb2l)
+ 
+ mb1ul <- mmlt(b1ul, b2ul, data = d)
+ mb2ul <- mmlt(b2ul, b1ul, data = d)
+ logLik(mb1ul)
+ logLik(mb2ul)
+ 
+ ## compare coef
+ ## log_first = TRUE
+ beta
+ coef(mb1)
+ coef(mb2)
+ value
+ ## compare coef
+ # coef(mb1)
+ # coef(mb2)
+ coef(mb1, type = "Lambda")[1,]
+ coef(mb2, type = "Lambda")[1,]
+ coef(mb1, type = "Corr")[1,]
+ coef(mb2, type = "Corr")[1,]
+ 
+ coef(mb1u, type = "Lambda")[1,]
+ coef(mb2u, type = "Lambda")[1,]
+ coef(mb1u, type = "Corr")[1,]
+ coef(mb2u, type = "Corr")[1,]
+ 
+ ## log_first = FALSE
+ # coef(mb1l)
+ # coef(mb2l)
+ coef(mb1l, type = "Lambda")[1,]
+ coef(mb2l, type = "Lambda")[1,]
+ coef(mb1l, type = "Corr")[1,]
+ coef(mb2l, type = "Corr")[1,]
+ 
+ coef(mb1ul, type = "Lambda")[1,]
+ coef(mb2ul, type = "Lambda")[1,]
+ coef(mb1ul, type = "Corr")[1,]
+ coef(mb2ul, type = "Corr")[1,]
+ 
+ ## transformation theory check
+ ## for constant lambdas, the transformed coefficients should agree with the
+ ## coefficients of the model with the different order
+ 
+ ## log_first = TRUE
+ coef(mb1)[-c(1:7, 15)] / sqrt(coef(mb1, type = "Sigma")$diagonal[1,2])
+ coef(mb2)[1:7]
+ 
+ coef(mb2)[-c(1:7, 15)] / sqrt(coef(mb2, type = "Sigma")$diagonal[1,2])
+ coef(mb1)[1:7]
+ 
+ coef(mb1u)[-c(1:7, 15)] / sqrt(coef(mb1u, type = "Sigma")$diagonal[1,2])
+ coef(mb2u)[1:7]
+ 
+ coef(mb2u)[-c(1:7, 15)] / sqrt(coef(mb2u, type = "Sigma")$diagonal[1,2])
+ coef(mb1u)[1:7]
+ 
+ ## log_first = FALSE
+ ## doesn't seem to be the case for log_first = FALSE?
+ coef(mb1l)[-c(1:7, 15)] / sqrt(coef(mb1l, type = "Sigma")$diagonal[1,2])
+ coef(mb2l)[1:7]
+ 
+ coef(mb2l)[-c(1:7, 15)] / sqrt(coef(mb2l, type = "Sigma")$diagonal[1,2])
+ coef(mb1l)[1:7]
+ 
+ coef(mb1ul)[-c(1:7, 15)] / sqrt(coef(mb1ul, type = "Sigma")$diagonal[1,2])
+ coef(mb2ul)[1:7]
+ 
+ coef(mb2ul)[-c(1:7, 15)] / sqrt(coef(mb2ul, type = "Sigma")$diagonal[1,2])
+ coef(mb1ul)[1:7]
+ 
+ ### predict accuracy
+ cbind(b1 = predict(b1, newdata = d[1:3, ], type = "distribution"),
+       mb1 = predict(mb1, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       mb2 = predict(mb2, marginal = 2, newdata = d[1:3, ], type = "distribution"))
+ cbind(b2 = predict(b2, newdata = d[1:3, ], type = "distribution"),
+       mb1 = predict(mb1, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       mb2 = predict(mb2, marginal = 1, newdata = d[1:3, ], type = "distribution"))
+ 
+ cbind(b1u = predict(b1u, newdata = d[1:3, ], type = "distribution"),
+       mb1u = predict(mb1u, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       mb2u = predict(mb2u, marginal = 2, newdata = d[1:3, ], type = "distribution"))
+ cbind(b2u = predict(b2u, newdata = d[1:3, ], type = "distribution"),
+       mb1u = predict(mb1u, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       mb2u = predict(mb2u, marginal = 1, newdata = d[1:3, ], type = "distribution"))
+ 
+ cbind(b1l = predict(b1l, newdata = d[1:3, ], type = "distribution"),
+       mb1l = predict(mb1l, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       mb2l = predict(mb2l, marginal = 2, newdata = d[1:3, ], type = "distribution"))
+ cbind(b2l = predict(b2l, newdata = d[1:3, ], type = "distribution"),
+       mb1l = predict(mb1l, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       mb2l = predict(mb2l, marginal = 1, newdata = d[1:3, ], type = "distribution"))
+ 
+ cbind(b1ul = predict(b1ul, newdata = d[1:3, ], type = "distribution"),
+       mb1ul = predict(mb1ul, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       mb2ul = predict(mb2ul, marginal = 2, newdata = d[1:3, ], type = "distribution"))
+ cbind(b2ul = predict(b2ul, newdata = d[1:3, ], type = "distribution"),
+       mb1ul = predict(mb1ul, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       mb2ul = predict(mb2ul, marginal = 1, newdata = d[1:3, ], type = "distribution"))
+ 
+ ## QQ-plot to check that marginal transformations are standard normal:
+ nd <- d
+ par(mfrow = c(2, 2))
+ d1 <- predict(mb1, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
+ qqline(d1, col = "red")
+ 
+ d2 <- predict(mb1, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
+ qqline(d2, col = "red")
+ 
+ d3 <- predict(mb2, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
+ qqline(d3, col = "red")
+ 
+ d4 <- predict(mb2, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
+ qqline(d4, col = "red")
+ 
+ 
+ d1 <- predict(mb1u, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
+ qqline(d1, col = "red")
+ 
+ d2 <- predict(mb1u, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
+ qqline(d2, col = "red")
+ 
+ d3 <- predict(mb2u, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
+ qqline(d3, col = "red")
+ 
+ d4 <- predict(mb2u, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
+ qqline(d4, col = "red")
+ 
+ ## log_first = FALSE
+ d1 <- predict(mb1l, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
+ qqline(d1, col = "red")
+ 
+ d2 <- predict(mb1l, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
+ qqline(d2, col = "red")
+ 
+ d3 <- predict(mb2l, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
+ qqline(d3, col = "red")
+ 
+ d4 <- predict(mb2l, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
+ qqline(d4, col = "red")
+ 
+ 
+ d1 <- predict(mb1ul, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
+ qqline(d1, col = "red")
+ 
+ d2 <- predict(mb1ul, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
+ qqline(d2, col = "red")
+ 
+ d3 <- predict(mb2ul, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
+ qqline(d3, col = "red")
+ 
+ d4 <- predict(mb2ul, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
+ qqline(d4, col = "red")
+ 
+ #############################################################
+ ###### lambda = lambda(x), marginal models ~ x.1 + x.2 ######
+ #############################################################
+ 
+ ## data
+ ## need to simulate data with lambdas that depend on x.1, x.2
+ set.seed(2701)
+ N <- 1000
+ J <- 2
+ x <- matrix(runif(N * J), ncol = J)
+ 
+ beta <- c(1, -1, -.5, .5)
+ # beta <- rep(0, 4)
+ 
+ xb <- x %*% matrix(beta, nrow = 2)
+ ly <- xb
+ 
+ lb <- (off_l <- 0.4) + x %*% (cf_l <- c(1.3, 0.6))
+ # plot(lb)
+ cr <- numeric(N)
+ 
+ for (i in 1:N) {
+    L_i <- diag(J)
+    L_i[2, 1] <- lb[i]
+    S_i <- tcrossprod(solve(L_i))
+    ly[i, ] <- ly[i, ] + rmvnorm(1, sigma = S_i)
+    cr[i] <- cov2cor(S_i)[1, 2]
+ }
+ 
+ ly_marg <- pnorm(ly)
+ y <- qbinom(ly_marg, size = 10, prob = 0.3) 
+ 
+ ## or take different distributions for the two margins
+ # y <- ly
+ # y[,1] <- qbinom(ly_marg[,1], size = 15, prob = 0.2) 
+ # y[,2] <- qbinom(ly_marg[,2], size = 10, prob = 0.3) 
+ 
+ # d <- data.frame(y = y, x = x)
+ yt <- y - 0.5*(y > 0)
+ ytt <- yt + 1
+ ytu <- y - runif(length(y))*(y > 0)
+ ytut <- ytu + 1
+ d <- data.frame(y = y, yt = yt, ytt = ytt, ytut = ytut, ytu = ytu, x = x)
+ # hist(d$y.1, breaks = 50)
+ # hist(d$y.2, breaks = 50)
+ # sort(unique(y)) ## we only have counts
+ # plot(y)
+ 
+ ##################################
+ ## cotram models for the marginals
+ u1 <- cotram(y.1 ~ x.1 + x.2, data = d, method = "probit")
+ u2 <- cotram(y.2 ~ x.1 + x.2, data = d, method = "probit")
+ 
+ ## joint models with different orders of the marginals, constant lambdas
+ uc1 <- mcotram(u1, u2, data = d, formula = ~ x.1 + x.2)
+ uc2 <- mcotram(u2, u1, data = d, formula = ~ x.1 + x.2)
+ logLik(uc1)
+ logLik(uc2) ## these log-likelihoods will not be the same
+ 
+ ## check gradient
+ all.equal(uc1$sc(uc2$par), numDeriv::grad(uc1$ll, uc2$par),
+           tol = 1e-6, check.attributes = FALSE)
+ 
+ ## marginal cotram models with log_first = FALSE
+ # uc1 <- uc2 <- 0
+ u1l <- cotram(y.1 ~ x.1 + x.2, data = d, method = "probit", log_first = FALSE)
+ u2l <- cotram(y.2 ~ x.1 + x.2, data = d, method = "probit", log_first = FALSE)
+ uc1l <- mcotram(u1l, u2l, data = d, formula = ~ x.1 + x.2)
+ uc2l <- mcotram(u2l, u1l, data = d, formula = ~ x.1 + x.2)
+ logLik(uc1l)
+ logLik(uc2l)
+ all.equal(uc1l$sc(uc2l$par), numDeriv::grad(uc1l$ll, uc2l$par),
+           tol = 1e-6, check.attributes = FALSE)
+ 
+ ## compare coefficients
+ ## recall true coefs:
+ beta
+ off_l
+ cf_l
+ 
+ R <- numeric(3)
+ for (i in 1:3) {
+    L <- diag(2)
+    L[2,1] <- lb[i]
+    S <- tcrossprod(solve(L))
+    R[i] <- cov2cor(S)[2, 1]
+ }
+ 
+ ## log_first = TRUE
+ coef(uc1)
+ coef(uc2)
+ cbind(lb[1:3], coef(uc1, type = "Lambda")[1:3,], coef(uc2, type = "Lambda")[1:3,])
+ cbind(orig = R, uc1 = coef(uc1, type = "Corr")[1:3,], 
+       uc2 = coef(uc2, type = "Corr")[1:3,])
+ 
+ ## log_first = FALSE
+ coef(uc1l)
+ coef(uc2l)
+ cbind(orig = lb[1:3], uc1l = coef(uc1l, type = "Lambda")[1:3,], 
+       uc2l = coef(uc2l, type = "Lambda")[1:3,])
+ cbind(orig = R, uc1 = coef(uc1l, type = "Corr")[1:3,], 
+       uc2 = coef(uc2l, type = "Corr")[1:3,])
+ 
+ ### predict accuracy
+ cbind(u1 = predict(u1, newdata = d[1:3, ], type = "distribution"),
+       uc1 = predict(uc1, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       uc2 = predict(uc2, marginal = 2, newdata = d[1:3, ], type = "distribution"))
+ cbind(u2 = predict(u2, newdata = d[1:3, ], type = "distribution"),
+       uc1 = predict(uc1, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       uc2 = predict(uc2, marginal = 1, newdata = d[1:3, ], type = "distribution"))
+ 
+ cbind(u1l = predict(u1l, newdata = d[1:3, ], type = "distribution"),
+       uc1l = predict(uc1l, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       uc2l = predict(uc2l, marginal = 2, newdata = d[1:3, ], type = "distribution"))
+ cbind(u2l = predict(u2l, newdata = d[1:3, ], type = "distribution"),
+       uc1l = predict(uc1l, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       uc2l = predict(uc2l, marginal = 1, newdata = d[1:3, ], type = "distribution"))
+ 
+ ## QQ-plot to check that marginal transformations are standard normal:
+ nd <- d
+ par(mfrow = c(2, 2))
+ d1 <- predict(uc1, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
+ qqline(d1, col = "red")
+ 
+ d2 <- predict(uc1, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
+ qqline(d2, col = "red")
+ 
+ d3 <- predict(uc2, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
+ qqline(d3, col = "red")
+ 
+ d4 <- predict(uc2, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
+ qqline(d4, col = "red")
+ 
+ ## log_first = FALSE
+ d1 <- predict(uc1l, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
+ qqline(d1, col = "red")
+ 
+ d2 <- predict(uc1l, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
+ qqline(d2, col = "red")
+ 
+ d3 <- predict(uc2l, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
+ qqline(d3, col = "red")
+ 
+ d4 <- predict(uc2l, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
+ qqline(d4, col = "red")
+ 
+ #### continuous approximation
+ ## univariate BoxCox models, log_first = TRUE
+ b1 <- BoxCox(ytt.1 ~ x.1 + x.2, data = d, log_first = TRUE)
+ b2 <- BoxCox(ytt.2 ~ x.1 + x.2, data = d, log_first = TRUE)
+ b1u <- BoxCox(ytut.1 ~ x.1 + x.2, data = d, log_first = TRUE)
+ b2u <- BoxCox(ytut.2 ~ x.1 + x.2, data = d, log_first = TRUE)
+ logLik(b1)
+ logLik(b1u)
+ logLik(b2)
+ logLik(b2u)
+ 
+ b1l <- BoxCox(yt.1 ~ x.1 + x.2, data = d, log_first = FALSE)
+ b2l <- BoxCox(yt.2 ~ x.1 + x.2, data = d, log_first = FALSE)
+ b1ul <- BoxCox(ytu.1 ~ x.1 + x.2, data = d, log_first = FALSE)
+ b2ul <- BoxCox(ytu.2 ~ x.1 + x.2, data = d, log_first = FALSE)
+ logLik(b1l)
+ logLik(b1ul)
+ logLik(b2l)
+ logLik(b2ul)
+ 
+ ## multivariate mmlt models
+ mb1 <- mmlt(b1, b2, data = d, formula = ~ x.1 + x.2)
+ mb2 <- mmlt(b2, b1, data = d, formula = ~ x.1 + x.2)
+ logLik(mb1)
+ logLik(mb2) ## these log-likelihoods are *not* expected to be the same
+ 
+ mb1l <- mmlt(b1l, b2l, data = d, formula = ~ x.1 + x.2)
+ mb2l <- mmlt(b2l, b1l, data = d, formula = ~ x.1 + x.2)
+ logLik(mb1l)
+ logLik(mb2l)
+ 
+ ## compare coefficients
+ ## recall true coefs:
+ beta
+ off_l
+ cf_l
+ 
+ ## log_first = TRUE
+ coef(mb1)
+ coef(mb2)
+ cbind(lb[1:3], coef(mb1, type = "Lambda")[1:3,], coef(mb2, type = "Lambda")[1:3,])
+ cbind(orig = R, mb1 = coef(mb1, type = "Corr")[1:3,], 
+       mb2 = coef(mb2, type = "Corr")[1:3,])
+ 
+ coef(mb1u)
+ coef(mb2u)
+ cbind(lb[1:3], coef(mb1u, type = "Lambda")[1:3,], coef(mb2u, type = "Lambda")[1:3,])
+ cbind(orig = R, mb1u = coef(mb1u, type = "Corr")[1:3,], 
+       mb2u = coef(mb2u, type = "Corr")[1:3,])
+ 
+ ## log_first = FALSE
+ coef(mb1l)
+ coef(mb2l)
+ cbind(lb[1:3], coef(mb1l, type = "Lambda")[1:3,], coef(mb2l, type = "Lambda")[1:3,])
+ cbind(orig = R, mb1l = coef(mb1l, type = "Corr")[1:3,], 
+       mb2l = coef(mb2l, type = "Corr")[1:3,])
+ 
+ coef(mb1ul)
+ coef(mb2ul)
+ cbind(lb[1:3], coef(mb1ul, type = "Lambda")[1:3,], coef(mb2ul, type = "Lambda")[1:3,])
+ cbind(orig = R, mb1ul = coef(mb1ul, type = "Corr")[1:3,], 
+       mb2ul = coef(mb2ul, type = "Corr")[1:3,])
+ 
+ ### predict accuracy
+ cbind(b1 = predict(b1, newdata = d[1:3, ], type = "distribution"),
+       mb1 = predict(mb1, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       mb2 = predict(mb2, marginal = 2, newdata = d[1:3, ], type = "distribution"))
+ cbind(b2 = predict(b2, newdata = d[1:3, ], type = "distribution"),
+       mb1 = predict(mb1, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       mb2 = predict(mb2, marginal = 1, newdata = d[1:3, ], type = "distribution"))
+ 
+ cbind(b1u = predict(b1u, newdata = d[1:3, ], type = "distribution"),
+       mb1u = predict(mb1u, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       mb2u = predict(mb2u, marginal = 2, newdata = d[1:3, ], type = "distribution"))
+ cbind(b2u = predict(b2u, newdata = d[1:3, ], type = "distribution"),
+       mb1u = predict(mb1u, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       mb2u = predict(mb2u, marginal = 1, newdata = d[1:3, ], type = "distribution"))
+ 
+ cbind(b1l = predict(b1l, newdata = d[1:3, ], type = "distribution"),
+       mb1l = predict(mb1l, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       mb2l = predict(mb2l, marginal = 2, newdata = d[1:3, ], type = "distribution"))
+ cbind(b2l = predict(b2l, newdata = d[1:3, ], type = "distribution"),
+       mb1l = predict(mb1l, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       mb2l = predict(mb2l, marginal = 1, newdata = d[1:3, ], type = "distribution"))
+ 
+ cbind(b1ul = predict(b1ul, newdata = d[1:3, ], type = "distribution"),
+       mb1ul = predict(mb1ul, marginal = 1, newdata = d[1:3, ], type = "distribution"),
+       mb2ul = predict(mb2ul, marginal = 2, newdata = d[1:3, ], type = "distribution"))
+ cbind(b2ul = predict(b2ul, newdata = d[1:3, ], type = "distribution"),
+       mb1ul = predict(mb1ul, marginal = 2, newdata = d[1:3, ], type = "distribution"),
+       mb2ul = predict(mb2ul, marginal = 1, newdata = d[1:3, ], type = "distribution"))
+ 
+ ## QQ-plot to check that marginal transformations are standard normal:
+ nd <- d
+ par(mfrow = c(2, 2))
+ d1 <- predict(mb1, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
+ qqline(d1, col = "red")
+ 
+ d2 <- predict(mb1, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
+ qqline(d2, col = "red")
+ 
+ d3 <- predict(mb2, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
+ qqline(d3, col = "red")
+ 
+ d4 <- predict(mb2, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
+ qqline(d4, col = "red")
+ 
+ 
+ d1 <- predict(mb1u, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
+ qqline(d1, col = "red")
+ 
+ d2 <- predict(mb1u, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
+ qqline(d2, col = "red")
+ 
+ d3 <- predict(mb2u, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
+ qqline(d3, col = "red")
+ 
+ d4 <- predict(mb2u, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
+ qqline(d4, col = "red")
+ 
+ ## log_first = FALSE
+ d1 <- predict(mb1l, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
+ qqline(d1, col = "red")
+ 
+ d2 <- predict(mb1l, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
+ qqline(d2, col = "red")
+ 
+ d3 <- predict(mb2l, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
+ qqline(d3, col = "red")
+ 
+ d4 <- predict(mb2l, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
+ qqline(d4, col = "red")
+ 
+ 
+ d1 <- predict(mb1ul, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d1, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 12, marginal = 1")
+ qqline(d1, col = "red")
+ 
+ d2 <- predict(mb1ul, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d2, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 12, marginal = 2")
+ qqline(d2, col = "red")
+ 
+ d3 <- predict(mb2ul, marginal = 2, newdata = d, type = "trafo")
+ qqnorm(d3, pch = 19, col = rgb(.1, .1, .1, .1), main = "order = 21, marginal = 2")
+ qqline(d3, col = "red")
+ 
+ d4 <- predict(mb2ul, marginal = 1, newdata = d, type = "trafo")
+ qqnorm(d4, pch = 19, col = rgb(.1, .1, .1, .1), main = "oder = 21, marginal = 2")
+ qqline(d4, col = "red")
+ 
+ }
> 
> 
> ## add tests for diag = TRUE in future?
> ## add J = 3?
> 
> proc.time()
   user  system elapsed 
  10.59    0.13   10.70 
